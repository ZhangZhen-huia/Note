# 使用过程中遇到的问题

## 1.一个can可以开两个fifo，但是两个can同时用，就只能一个开一个fifo了



# TIM

在STM32F4 HAL库中修改定时器的ARR（自动重装载寄存器）值时，需要注意以下几点以确保定时器能够正常工作：

1. **停止定时器**：在修改ARR值之前，需要先停止定时器。这是因为直接在定时器运行时修改ARR可能会导致定时器行为异常。可以通过调用`HAL_TIM_Base_Stop(&htim);`来停止定时器。

2. **修改ARR值**：停止定时器后，可以直接通过访问定时器实例的ARR寄存器来修改重装载值，例如：`htim.Instance->ARR = new_arr_value;`。

3. **重新启动定时器**：修改完ARR值后，需要重新启动定时器，以便新的ARR值生效。可以通过调用`HAL_TIM_Base_Start(&htim);`来启动定时器。

4. **考虑ARPE位**：在TIMx_CR1寄存器中有一个ARPE（Auto-reload preload enable）位，用于控制预装载寄存器的内容何时传送到影子寄存器。如果ARPE位被设置为1，则修改ARR的值会影响下下一个周期的定时长度；如果设置为0，则修改ARR的值会影响下一个周期的定时长度。

5. **避免中断冲突**：如果在中断服务程序中修改ARR值，需要确保不会引发中断冲突或丢失中断。可能需要禁用相应的中断，修改ARR值后再重新使能中断。

6. **检查HAL_TIM_PeriodElapsedCallback回调函数**：确保在修改ARR值后，回调函数`HAL_TIM_PeriodElapsedCallback`能够正确响应新的定时周期。

如果在连续修改两次ARR值后发现无法进入中断，可能是因为没有正确地停止和启动定时器，或者是ARPE位的设置不当导致新的ARR值没有立即生效。请按照上述步骤操作，并检查代码中的其他可能错误，以确保定时器能够按照预期工作。



如果在STM32F4系列微控制器中，当前的ARR值已经大于你想要修改的ARR值，并且没有ARPE位（即自动重装载预装载功能未启用），那么修改ARR值后可能会有以下影响：

1. **计数器行为**：由于STM32的定时器计数器是连续计数的，如果当前计数器的值（CNT）大于新的ARR值，计数器会继续计数直到达到当前周期的结束（即计数器值达到当前ARR值），然后才会根据新的ARR值重新开始计数。这意味着在当前周期结束之前，计数器不会立即响应ARR值的变化。
2. **中断响应**：如果你依赖于定时器的周期性中断，那么在当前周期结束之前，中断不会根据新的ARR值触发。这可能导致中断服务程序（ISR）中的代码执行延迟，直到计数器溢出并根据新的ARR值重新开始计数。
3. **PWM输出影响**：如果你使用定时器产生PWM波形，那么在当前周期结束之前，PWM的频率和占空比不会立即改变。这可能导致PWM输出在一段时间内不符合预期，直到计数器完成当前周期并根据新的ARR值重新开始计数。
4. **非预期的计数段**：如果在修改ARR值时，当前计数器值大于新的ARR值，那么可能会出现一段非预期的计数段。这段时间内，定时器的行为可能不是用户预期的，例如PWM输出可能在这段时间内保持低电平或高电平，直到计数器达到新的ARR值。

为了避免这些问题，建议在修改ARR值之前停止定时器，修改ARR值后再重新启动定时器，这样可以确保新的ARR值立即生效。如果需要在定时器运行中修改ARR值，可以考虑使用预装载寄存器（如果支持），或者在修改ARR值后通过软件触发一个更新事件（UEV），使计数器立即重装新的计数初值

