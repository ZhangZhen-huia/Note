# 简略视图

![image-20250304213309060](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503042133116.png)

# 寄存器组

Cortex-M3处理器有15个寄存器组R0~R15，其中R13作为堆栈指针SP，有两个，但在同一时刻只能出现一个，叫做banked寄存器

![image-20250305102724463](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051027533.png)

## R0~R12

——为32位通用寄存器，用于数据操作

> 绝大多数 16 位 Thumb 指令只能访 问 R0‐R7，而 32 位 Thumb‐2 指令可以访问所有寄存器

## Banked13

——两个堆栈指针

- 主堆栈指针MSP：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包括中断服务例程）
- 进程堆栈指针PSP：由用户的应用程序代码使用

> **堆栈指针的最低两位永远是 0，这意味着堆栈总是 4 字节对齐的**

## R14

——连接寄存器

当呼叫一个子程序时，由 R14 存储返回地址，减少访问内存的次数，这样足以使很多只有 1 级子程序调用的代码无需访问内存（堆栈内存），从而提高了子程序调用的效率

## R15

——程序计数寄存器

> 指向当前的程序地址。如果修改它的值，就能改变程序的执行流

## 特殊功能寄存器

Cortex‐M3 还在内核水平上搭载了若干特殊功能寄存器

- 程序状态字寄存器组（PSRs）
- 中断屏蔽寄存器组（PRIMASK, FAULTMASK, BASEPRI）
- 控制寄存器（CONTROL）
- ![image-20250305104020424](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051040456.png)

![image-20250305104116404](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051041444.png)

**BASEPRI在FreeRtos里面有很大的应用，用于快速开关中断进入临界区，在《野火》临界段那一篇有笔记**

# 操作模式和特权极别 

> Cortex‐M3 处理器支持两种处理器的操作模式，还支持两级特权操作

两种操作模式：处理者模式(handler mode)和线程模式（thread mode）

特权的分级：特权级和用户级

在 CM3 运行主应用程序时（线程模式），既可以使用特权级，也可以使用用户级，但是异常服 务例程必须在特权级下执行

复位后，处理器默认进入线程模式，特权极访问，在特权级下，程序可以访问所有范围的存储器（如果有 MPU，还要在 MPU 规定的禁地之外），并且可以执行所有指令

程序进入用户级后想要回到特权级，就不能简简单单地试图改写 **CONTROL** 寄存器就回到特权级，它必须先“申诉”：执行一条系统调用指令(SVC），这会触发 SVC 异常，然后由异常服务例程（通常是操作系统的一部分）接管，如果批准了进入，则异常服务例程修改 CONTROL 寄存 器，才能在用户级的线程模式下重新进入特权级

从用户级到特权级的唯一途径就是异常：如果在程序执行过程中触发了一个异常，处 理器总是先切换入特权级，并且在异常服务例程执行完毕退出时，返回先前的状态

![image-20250305112504376](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051125422.png)

# 嵌套向量中断控制器 NVIC

- 可嵌套中断支持：支持抢占中断服务例程和普通程序
- 向量中断支持：当开始响应一个中断后，CM3 会自动定位一张向量表，并且根据中断号从表中找出 ISR 的入口 地址，然后跳转过去执行。
- 动态优先级调整支持：软件可以在运行时期更改中断的优先级。如果在某 ISR 中修改了自己所对应中断的优先级，而且这个中断又有新的实例处于悬起中（pending），也不会自己打断自己，即会先等待当前正在执行的中断执行完，再去响应新的中断
- 中断延迟大大缩短：“咬尾中断”和“晚到中断“
- 中断可屏蔽 ：BASEPRI，PRIMASK，FAULTMASK寄存器

# 存储器映射

Cortex‐M3 支持 4GB 存储空间

![image-20250305114103990](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051141034.png)

![image-20250305114542851](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051145022.png)

# 总线接口

> - 指令存储区总线（两条）：
>   - I-Code总线
>     - 负责从存储器中**读取指令**，以便 CPU 执行程序。程序存储器通常包含编译后的程序代码，这些代码以指令的形式存储在存储器中。I-Code 总线将 Cortex™-M3 内核的指令总线与闪存指令接口相连接，使得内核能够从闪存中读取指令
>     - I-Code 总线在存储器地址 0x0000_0000 至 0x1FFF_FFFF 之间进行取指操作
>   - D-Code总线
>     - 用于读取和写入数据，这些数据可以是程序中的常量、变量，或者是调试过程中需要访问的数据
>     - 负责在存储器地址 0x0000_0000 – 0x1FFF_FFFF 之间的数据访问操作
> - 系统总线：用于访问内存和外设，覆盖的区域包括 SRAM，片上外设，片外 RAM，片外扩展设备， 以及系统级存储区的部分空间
> - 私有外设总线：负责一部分私有外设的访问，主要就是访问调试组件。它们也在系统级存储区

![](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051151503.png)

# 存储器保护单元（MPU）

> 有一个可选的存储器保护单元。配上它之后，就可以对特权级访问和用户级访问分 别施加不同的访问限制。当检测到犯规（violated）时，MPU 就会产生一个 fault 异常，可以由 fault 异常的服务例程来分析该错误，并且在可能时改正它

# 指令集

Cortex‐M3 只使用 Thumb‐2 指令集

它允许 32 位指令和 16 位指令同时存在

# 中断和异常

它支持 16‐4‐1=11 种系统异常（保留了 4+1 个档位），外加 240 个外部中断输入。

![image-20250305122942157](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051229221.png)

![image-20250305122949007](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202503051229041.png)

> 虽然 CM3 是支持 240 个外中断的，但具体使用了多少个是由芯片生产商决定。CM3 还有一个 NMI（不可屏蔽中断）输入脚。当它被置为有效（assert）时，NMI 服务例程会无条件地执行