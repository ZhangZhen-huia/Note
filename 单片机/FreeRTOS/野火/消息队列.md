# 基本概念

队列又称消息队列，用于任务与任务之间，任务与中断之间的通信，可以规定阻塞时间，消息队列是一种异步的通信方式。

- 遵循FIFO原则先入先出和LIFO原则后入先出
- 一个任务能够从任意一个消息队列接收和发送消息
- 多个任务能够从同一个消息队列接收和发送消息
- 可以允许不同长度（不超过队列节点最大值）的任意类型消息

# 运作机制

创建队列的时候FreeRTOS会为队列分配一块内存，内存大小等于

- 消息队列控制块大小加上单个消息空间大小与消息队列长度的乘积

![image-20250211111255539](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202502111112608.png)

# 阻塞机制

- 不等
- 等一段时间
- 死等
- 只能在任务中阻塞，在中断中不允许阻塞，要用专门的ISR函数
- 高优先级优先获得，否则等待时间最长的任务优先获得

# 控制块

```c
typedef struct QueueDefinition
{
	int8_t *pcHead;					/*头指针，指向队列消息存储区起始位置，即第一个消息空间*/
	int8_t *pcTail;					/*<尾指针，指向队列消息存储区结束位置.在分配内存以存储队列项时，会多分配一个字节，这个额外的字节被用作一个标记 */
	int8_t *pcWriteTo;				/*< 指向队列消息存储区下一个可用消息空间 */

	union							/* pcReadFrom 与 uxRecursiveCallCount 是一对互斥变量，使用联合体用来确保两个互斥的结构体成员不会同时出现 */
	{
		int8_t *pcReadFrom;			/*< 当结构体用于队列时，pcReadFrom 指向出队消息空间的最后一个，在读数据时表示上一次读数据的位置. */
		UBaseType_t uxRecursiveCallCount;/*<当结构体用于互斥量时，uxRecursiveCallCount 用于计数，记录递归互斥量被“调用”的次数 */
	} u;

	List_t xTasksWaitingToSend;		/*发送消息阻塞列表. 任务按照优先级进行排序 */
	List_t xTasksWaitingToReceive;	/*获取消息阻塞列表.  任务按照优先级进行排序*/

	volatile UBaseType_t uxMessagesWaiting;/*用于记录当前消息队列的消息个数，如果消息队列被用于信号量的时候，这个值就表示有效信号量个数 */
	UBaseType_t uxLength;			/*表示队列的长度，也就是能存放多少消息*/
	UBaseType_t uxItemSize;			/*表示单个消息的大小，单位：字节 */

	volatile int8_t cRxLock;		/*队列上锁后，储存从队列收到的列表项数目，也就是出队的数量，如果队列没有上锁，设置为 queueUNLOCKED*/
	volatile int8_t cTxLock;		/*队列上锁后，储存发送到队列的列表项数目，也就是入队的数量，如果队列没有上锁，设置为 queueUNLOCKED */
/*这两个成员变量为 queueUNLOCKED 时，表示队列未上锁；当这两个成员变量为queueLOCKED_UNMODIFIED 时，表示队列上锁*/
    
	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
	#endif
	
    //定义消息队列集，
	#if ( configUSE_QUEUE_SETS == 1 )
		struct QueueDefinition *pxQueueSetContainer;
	#endif

	#if ( configUSE_TRACE_FACILITY == 1 )
		UBaseType_t uxQueueNumber;
		uint8_t ucQueueType;
	#endif

} xQUEUE;
```

# 创建

![image-20250212222417747](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202502122229714.png)

## xQueueCreate()

```c
#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )

```

## xQueueGenericCreate

```c
#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
	Queue_t *pxNewQueue; //指向新创建队列的指针
	size_t xQueueSizeInBytes; //队列存储区的大小（以字节为单位）
	uint8_t *pucQueueStorage; //指向队列存储区的指针，定义为无符号八位的指针类型，可以兼容各种数据类型

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/*消息存储空间大小为0 */
			xQueueSizeInBytes = ( size_t ) 0;
		}
		else
		{
			/* 消息存储空间大小 = 消息队列长度×单个消息的大小. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}
		
        //向系统申请队列的内存，内存为控制块大小+消息存储空间大小
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );

		if( pxNewQueue != NULL )
		{
			/*计算出消息存储空间的起始地址 */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );

			#if( configSUPPORT_STATIC_ALLOCATION == 1 ) 
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}

#endif

```

### prvInitialiseNewQueue()

```c
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
	{
		/*没有给消息队列分布内存空间，所以本应该给Pc指针NULL，但是这一操作是队列作为互斥量要用的，为了区分开，
        这里就把pcHead指向了一个已知的内存*/
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* 指向队列存储区的头部 */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}


	pxNewQueue->uxLength = uxQueueLength;//队列长度
	pxNewQueue->uxItemSize = uxItemSize;//单个消息空间的大小
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );// 重置消息队列

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
	}
	#endif /* configUSE_TRACE_FACILITY */

	#if( configUSE_QUEUE_SETS == 1 )
	{
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
/*-----------------------------------------------------------*/

```

### xQueueGenericReset()

```c
BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );//pcTail 指向存储消息内存空间的结束地
址
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;//前消息队列中的消息个数给0
		pxQueue->pcWriteTo = pxQueue->pcHead;//pcWriteTo 指向队列消息存储区下一个可用消息空间，因为是重置消息队列，就指向消息队列的第一个消息空间，也就是 pcHead 指向的空间
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );//pcReadFrom 指向消息队列最后一个消息空间。
		pxQueue->cRxLock = queueUNLOCKED;//消息队列没有上锁，设置为 queueUNLOCKED。
		pxQueue->cTxLock = queueUNLOCKED;
		
        //如果不是新建一个消息队列，那么该消息队列可能会阻塞一些任务，需要给他们消除，因为队列重置之后里面什么信息都没有了
		if( xNewQueue == pdFALSE )
		{
            //待写入阻塞不为空
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
                //清除，如果被阻塞的任务最高优先级大于当前任务的优先级，就会返回pdTURE
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					queueYIELD_IF_USING_PREEMPTION();//挂起PendSV，请求任务切换
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
        //是新创建的队列，就直接实行初始化
		else
		{
			/* 初始化待写入和待读出列表 */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
/*-----------------------------------------------------------*/
```

### xTaskRemoveFromEventList()

```c
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
	called from a critical section within an ISR. 只能在在临界区中调用*/

	/* The event list is sorted in priority order, so the first in the list can
	be removed as it is known to be the highest priority.  Remove the TCB from
	the delayed list, and add it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
    //获取事件列表中的第一个节点的所有者，因为事件列表是按照优先级排序的，所以就是获取最高优先级的任务句柄
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );//移除

    //调度器没有被挂起
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );//移除阻塞状态
		prvAddTaskToReadyList( pxUnblockedTCB );//加入就绪状态
	}
	else//调度器被挂起
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
        //加入待就绪列表
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}
	//刚获取的任务优先级大于当前任务优先级
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;//需要切换任务
	}
	else
	{
		xReturn = pdFALSE;//不切换
	}

	#if( configUSE_TICKLESS_IDLE != 0 )
	{
		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
		might be set to the blocked task's time out time.  If the task is
		unblocked for a reason other than a timeout xNextTaskUnblockTime is
		normally left unchanged, because it is automatically reset to a new
		value when the tick count equals xNextTaskUnblockTime.  However if
		tickless idling is used it might be more important to enter sleep mode
		at the earliest possible time - so reset xNextTaskUnblockTime here to
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
```

## xQueueCreateStatic()

```c
#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
```

队列长度，单个空间大小，指向队列存储区的指针，存储队列结构体数据的指针

## xQueueGenericCreateStatic()

如果创建成功则返回一个队列句柄，用于访问创建的队列。如果创建不成功则返回 NULL，可能原因是创建队列需要的 RAM 无法分配成功。

```c
#if( configSUPPORT_STATIC_ALLOCATION == 1 )
//队列深度,单个空间大小，指向队列存储区的指针，指向队列的指针，队列类型
	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
	{
	Queue_t *pxNewQueue;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* The StaticQueue_t structure and the queue storage area must be
		supplied. */
		configASSERT( pxStaticQueue != NULL );

		/* A queue storage area should be provided if the item size is not 0, and
		should not be provided if the item size is 0. */
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );

		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
			the real queue and semaphore structures. */
			volatile size_t xSize = sizeof( StaticQueue_t );
			configASSERT( xSize == sizeof( Queue_t ) );
		}
		#endif /* configASSERT_DEFINED */

		/* The address of a statically allocated queue was passed in, use it.
		The address of a statically allocated storage area was also passed in
		but is already set. */
		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */

		if( pxNewQueue != NULL )
		{
			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
			{
				/* Queues can be allocated wither statically or dynamically, so
				note this queue was allocated statically in case the queue is
				later deleted. */
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}

```

# 删除

## vQueueDelete()

如果删除消息队列时，有任务正在等待消息，则不应 该进行删除操作（官方说的是不允许进行删除操作，但是源码并没有禁止删除的操作

```c
void vQueueDelete( QueueHandle_t xQueue )
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );
	//宏定义，设置可以注册的信号量和消息队列个数
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
        //将消息队列从注册表中删除
		vQueueUnregisterQueue( pxQueue );
	}
	#endif

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
	}
	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
	{
		/* The queue could have been allocated statically or dynamically, so
		check before attempting to free the memory. */
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
		{
			vPortFree( pxQueue );
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#else
	{
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}

```

### vQueueUnregisterQueue()

```c
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
				break;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */

#endif /* configQUEUE_REGISTRY_SIZE */
```

# 发送

等待超时后，发送消息的任务或者中断程序会收到 一个错误码 errQUEUE_FULL

发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，发送 的位置是消息队列队头而非队尾，这样，接收者就能够优先接收到紧急消息，从而及时进 行消息处理。

## xQueueSend()	&&	xQueueSendToBack()

- 发送的队列

- 指针，指向要发送到队列尾部的队列消息

- 等待时间
- 消息发送成功成功返回 pdTRUE，否则返回 errQUEUE_FULL

```c
#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ),( xTicksToWait ), queueSEND_TO_BACK )
```

```c
#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
```

消息以拷贝的形式入队，而不是以引用的形式，不能在中断中使用

## xQueueSendToFront()

```c
 #define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ),( xTicksToWait ), queueSEND_TO_FRONT )
```

## xQueueGenericSend()

注意：这里发送的数据是用memcpy拷贝的，所以就算该数据已经超过了一个消息空间的大小，也不会报错，因为memcpy只会拷贝一个消息空间的大小的数据进入队列

**接收消息也是一样**

```c
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );//验证队列句柄 xQueue 不为空。
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );//如果队列的单个项大小非零（uxItemSize != 0），则确保 pvItemToQueue 不为空
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );//如果 xCopyPosition 设置为 queueOVERWRITE，则确保队列长度为 1
    
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
        //如果调度器被挂起（taskSCHEDULER_SUSPENDED），则确保 xTicksToWait 为 0，因为调度器挂起时无法等待
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	for( ;; )
	{
		taskENTER_CRITICAL();//进入临界区
		{
			/* 如果队列未满，或着写入模式是覆写 I */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
			{
				traceQUEUE_SEND( pxQueue );
                //复制数据到队列中，该函数的返回值表示是否需要切换任务
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

                //队列集
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
						{
							/* 这个是任务有多个互斥锁, 并且返回的顺序不对 */
							queueYIELD_IF_USING_PREEMPTION();
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else if( xYieldRequired != pdFALSE )
						{
							/* This path is a special case that will only get
							executed if the task was holding multiple mutexes
							and the mutexes were given back in an order that is
							different to that in which they were taken. */
							queueYIELD_IF_USING_PREEMPTION();
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/*如果有任务在等待获取此消息队列. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
                        //取消该任务的阻塞，函数返回值表示取消阻塞的任务优先级是否大于当前任务优先级，pdTURE大于
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							/* 切换任务. */
							queueYIELD_IF_USING_PREEMPTION();
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
					{
						/* 如果没有等待的任务，拷贝成功也需要任务切换*/
						queueYIELD_IF_USING_PREEMPTION();
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();//退出临界区
				return pdPASS;
			}
            //队列满了并且也不是覆写模式
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* 如果用户不指定阻塞超时时间，退出 */
					taskEXIT_CRITICAL();

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
                //并且超时时间还未设置
				else if( xEntryTimeSet == pdFALSE )
				{
					/* 初始化阻塞超时结构体变量，初始化进入阻塞的时间 xTickCount 和溢出次数 xNumOfOverflows */
					vTaskSetTimeOutState( &xTimeOut );//结构体直接赋值
					xEntryTimeSet = pdTRUE;
				}
				else
				{
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();//退出临界区

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();//挂起调度器
		prvLockQueue( pxQueue );//cRxLock，cTxLock队列上锁，简单的宏定义判断赋值，如果未上锁就上锁
        /*简单粗暴挂起调度器就不会进行任务切换，但是挂起调度器并不会禁止中断的发生，所以还需给队列上锁，因为系统不希望突然有中断操作这个队列的 xTasksWaitingToReceive 列表和 xTasksWaitingToSend 列表*/

		/* 阻塞时间还没有到期 */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
            //队列已经满了，宏定义判断队列已有长度和定义的的长度
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                //把任务加入xTasksWaitingToSend事件列表，然后加入阻塞列表，阻塞时间为xTicksToWait
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );

				/* 解锁互斥量. */
				prvUnlockQueue( pxQueue );

				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
				}
			}
            //队列未满
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
			}
		}
		else//阻塞时间到期了
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;//写入失败
		}
	}
}
```

### xTaskCheckForTimeOut()

```c
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;

		#if( INCLUDE_xTaskAbortDelay == 1 )
			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
			{
				/* The delay was aborted, which is not the same as a time out,
				but has the same result. */
				pxCurrentTCB->ucDelayAborted = pdFALSE;
				xReturn = pdTRUE;
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
			}
			else
		#endif

                //溢出一次并且超时
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
		{

			xReturn = pdTRUE;//阻塞时间到
		}
        //未超时，xTimeOnEntering是阻塞开始时间
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) 
		{
			/* 重新计算超时时间*/
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
```

### prvCopyDataToQueue()

```c
static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* 这个函数只能在临界区中被使用. */
	
    //获取队列中已经存储的信息长度
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

    //一般项大小为0就是互斥量
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
	{
		#if ( configUSE_MUTEXES == 1 )
		{
            //确保队列类型是互斥量
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* 解决优先级继承问题. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
               	 //释放互斥量的所有权，将互斥量的持有者设置为 NULL
				pxQueue->pxMutexHolder = NULL;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
    //发送至尾部
	else if( xPosition == queueSEND_TO_BACK )
	{
        //克隆数据从pvItemToQueue到pxQueue->pcWriteTo指针指向的地方，大小为一个消息空间的大小
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
        
        //移动写入指针到下一个位置
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
        //如果写入指针超过队列的末端指针，则将其重置为队列的起始位置（pcHead）
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) 
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    //发送置头部
	else
	{
        //使用 memcpy 将数据复制到队列的读取位置前面，因为队列是FIFO，所以写入头部的数据会被先读出来，所以就写入pcReadFrom指向的位置
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
        //移动读指针到上一个位置
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
        //读指针的位置已经移动出了队列头指针的位置
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) 
		{
            //就把读指针给到（队列尾部地址减去一个项目大小的)地址处，即尾指针前一个的消息地址，下一次读取的时候pcReadFrom加一个uxItemSize的地址，就会回到头部读取刚刚写入的数据了，因为pcReadFrom在读取数据的时候表示的是上一次读取的位置
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/*如果是覆写操作，就在这里减去一个消息，因为覆写不会改变队列中的消息个数，为了和后面的+1抵消这里就先-1. */
				--uxMessagesWaiting;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;

	return xReturn;
}

```

### xTaskPriorityDisinherit()

```c
#if ( configUSE_MUTEXES == 1 )//如果使能了互斥量

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;//任务句柄指针，指向持有互斥量的任务
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )//句柄不为空
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
            //确保含有互斥量的任务是当前正在运行的任务
			configASSERT( pxTCB == pxCurrentTCB );

            //确保互斥量计数大于 0
			configASSERT( pxTCB->uxMutexesHeld );
            
			( pxTCB->uxMutexesHeld )--;

			/* Has the holder of the mutex inherited the priority of another
			task? 判断互斥锁的持有者是否继承了另一个人的优先级任务，即判断任务的基础优先级和当前的优先级是否一致*/
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
			{
				/* Only disinherit if no other mutexes are held. 
				只有在没有其他互斥对象被持有的情况下才取消继承*/
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
				{
					/* 一个有互斥量的任务只有一个继承优先级. 如果互斥量被任务持有那么该互斥量就不能被中断给予
					如果互斥对象是由当前任务持有，那么它必须是运行状态任务  把当前任务从就绪列表删除 */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* 取消继承优先级. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;//令继承优先级等于当前优先级

					/* 重新设置列表项值 */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); 
                    //加入就绪列表
					prvAddTaskToReadyList( pxTCB );

					/* 返回pdTURE表示需要切换任务.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}

#endif /* configUSE_MUTEXES */

```

### vTaskPlaceOnEventList()

```c
void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
	configASSERT( pxEventList );

	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
```



## xQueueSendFromISR()   	&& 	xQueueSendToBackFromISR()

- 队列句柄
- 指针，指向要发送到队列尾部的消息
- pxHigherPriorityTaskWoken ：如果入队导致一个任务解锁，并且解锁的任务优先级高 于当前被中断的任务，则将*pxHigherPriorityTaskWoken 设置成 pdTRUE，然后在中断退出前需要进行一次上下 文 切 换 ， 去 执 行 被 唤 醒 的 优 先 级 更 高 的 任 务 。 从 FreeRTOS V7.3.0 起，pxHigherPriorityTaskWoken 作为一 个可选参数，可以设置为 NULL。
- 消息发送成功返回 pdTRUE，否则返回 errQUEUE_FULL

```
#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
```

```c
#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
```

## xQueueSendToFrontFromISR()

```c
#define xQueueSendToFrontFromISR( xQueue,pvItemToQueue,pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
```

## xQueueGenericSendFromISR()

中断不能阻塞发送

```c
BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

    //一堆断言操作
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );

	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
    //设置basepri寄存器来屏蔽中断
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
        //有空间或者覆写
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
			const int8_t cTxLock = pxQueue->cTxLock;

			traceQUEUE_SEND_FROM_ISR( pxQueue );

			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex. */
            //拷贝，不是互斥量就不用接收返回值
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* 队列未上锁. */
			if( cTxLock == queueUNLOCKED )
			{
                //队列集
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
							{
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
								}
								else
								{
									mtCOVERAGE_TEST_MARKER();
								}
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
				}
                //普通队列
				#else /* configUSE_QUEUE_SETS */
				{
                    //有任务在读取阻塞中
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
	                        //解除阻塞任务优先级比当前任务优先级高
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
                            
                            //参数不为空
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}//解除阻塞任务优先级没有当前任务优先级高
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
                    //没有任务在读取阻塞中
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */
			}
            //队列上锁了
			else
			{
				/* 队列上锁,记录上锁次数,等到任务解除队列锁时,使用这个计录数就可以知道有多少数据入队. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
		}
        //队列是满的
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;//写入失败
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );//清除中断屏蔽

	return xReturn;
}
```

# 读取

## xQueueReceive()

用于从一个队列中接收消息，并把接收的消息从队列中删除

```c
#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
```

## xQueuePeek()

函数接收消息完不会删除消息队列中的消息

```c
#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
```

## xQueueGenericReceive()

```c
BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

    //断言操作
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

			/* 队列中有数据 */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* 记录下读之前的指针指向，防止用户peek. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

                //copy
				prvCopyDataFromQueue( pxQueue, pvBuffer );
				//不是peek，即读后删除信息
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/*信息量-1 */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
					//支持互斥
					#if ( configUSE_MUTEXES == 1 )
					{
                        //类型是互斥
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); 
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */
					//写阻塞列表有任务
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
                        //可以取消阻塞了，且取消阻塞的任务比当前任务优先级高，就在退出临界区后进行任务切换
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
						{
							queueYIELD_IF_USING_PREEMPTION();
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
                    //没有被阻塞的任务
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
                //是peek，只读不删
				else
				{
					traceQUEUE_PEEK( pxQueue );

					/* 则读指针位置不变 */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* 因为读数据后没有删除，那就再看看读阻塞列表有无数据. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
                        //解除阻塞，并且任务优先级高
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							/*切换. */
							queueYIELD_IF_USING_PREEMPTION();
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
                    //没有读阻塞任务
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();//退出临界区
				return pdPASS;//读取成功
			}
			else//队列中无数据
			{
                //不等待，退出
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;//返回读取失败
				}
                //等待且未设置等待时间
				else if( xEntryTimeSet == pdFALSE )
				{
					//设置，标志位置pdTRUE
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
                //设置等待时间
				else
				{
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();//退临界区

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* 未超时. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
            //队列还没有一个信息
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                //互斥
				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
                       	//进临界区
						taskENTER_CRITICAL();
						{
                            //优先级继承
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
						}
						taskEXIT_CRITICAL();
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif
				//把任务加入xTasksWaitingToReceive事件列表，然后加入阻塞列表，阻塞时间为xTicksToWait
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
                //解锁队列
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )//恢复调度器
				{
					portYIELD_WITHIN_API();
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else//有消息了
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
			}
		}
        //已超时
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			//如果队列还是空的，就返回错误码
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}

```

### prvCopyDataFromQueue()

```c
static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    //单个消息空间大小不为0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
        //读指针地址往后移动一个项目大小
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
        //读指针超过了尾指针，即读指针已经出了该队列的环形缓冲区的范围了
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) 
		{
            //指向头指针
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
        //从读指针处copy一个消息空间大小的数据到用户给的缓冲区
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); 
	}
}

```

### vTaskPriorityInherit()

```c
void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

```

# 实验

```c
/* FreeRTOS头文件 */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
/* 开发板硬件bsp头文件 */
#include "bsp_led.h"
#include "bsp_usart.h"
#include "bsp_key.h"


/*任务*/
void AppTaskCreatTask(void*arg);
TaskHandle_t StartTaskHandle;

void SendTask(void*arg);
TaskHandle_t SendTaskHandle;

void RecTask(void*arg);
TaskHandle_t RecTaskHandle;

StaticTask_t Idle_Task_TCB;
StackType_t Idle_Task_Stack[configMINIMAL_STACK_SIZE];

/*消息队列*/
QueueHandle_t TestQueueHandle;

static void BSP_Init(void);/* 用于初始化板载相关资源 */




void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, 
																	 StackType_t **ppxIdleTaskStackBuffer, 
																	 uint32_t *pulIdleTaskStackSize);



int main(void)
{	

  /* 开发板硬件初始化 */
  	BSP_Init();
	if(xTaskCreate(AppTaskCreatTask,"StartTask",512,NULL,1,&StartTaskHandle)!= errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY)
		vTaskStartScheduler();
	else
		return -1;
  while(1);   /* 正常不会执行到这里 */    
}


void AppTaskCreatTask(void*arg)
{

	taskENTER_CRITICAL();

	if(xTaskCreate(RecTask,"RecTask",50,NULL,1,&RecTaskHandle) != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY)
	printf("RecTask Create successfully!	");

	if(xTaskCreate(SendTask,"SendTask",128,NULL,2,&SendTaskHandle) != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY)
	printf("SendTask Create successfully!	");

	if((TestQueueHandle = xQueueCreate(4,4)) != NULL)
	printf("Queue Create successfully!\n\n");

	vTaskDelete(NULL);
	taskEXIT_CRITICAL();
	while (1)
	{
		/* code */
	}
	
}

void RecTask(void *arg)
{
	BaseType_t xReturn = pdTRUE;/* 定义一个创建信息返回值，默认为 pdTRUE */ 
	char RecDATA[5]; /* 定义一个接收消息的变量 */ 
	while (1)
	 { 
		xReturn = xQueueReceive( TestQueueHandle,RecDATA,portMAX_DELAY);  
		if (pdTRUE == xReturn) 
			printf("RecDATA:%s\n\n",RecDATA); 
		 else 
		 printf("ERR: 0x%lx\n\n",xReturn); 
 } 	
}

void SendTask(void *arg)
{
	char SendData1[5] = "Good"; 
	char SendData2[4] = "BYE";
	while (1)
	{
		if(Key_Scan(KEY1_GPIO_PORT,KEY1_GPIO_PIN) == KEY_ON)
		{
			printf("Send Message1!	");
			if(xQueueSend(TestQueueHandle,SendData1,portMAX_DELAY) != errQUEUE_FULL)
				printf("Successfully!\n");
			else
				printf("Failed!\n");
		}
		if(Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) == KEY_ON)
		{
			printf("Send Message2!	");
			if(xQueueSend(TestQueueHandle,SendData2,portMAX_DELAY) != errQUEUE_FULL)
				printf("Successfully!\n\n");
			else
				printf("Failed!\n\n");
		}
		vTaskDelay(20);
	}
	
}

static void BSP_Init(void)
{
	/*
	 * STM32中断优先级分组为4，即4bit都用来表示抢占优先级，范围为：0~15
	 * 优先级分组只需要分组一次即可，以后如果有其他的任务需要用到中断，
	 * 都统一用这个优先级分组，千万不要再分组，切忌。
	 */
	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
	
	/* LED 初始化 */
	LED_GPIO_Config();

	/* 按键初始化 */
	Key_GPIO_Config();
	
	/* 串口初始化	*/
	USART_Config();
  
}
 

void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, 
								   StackType_t **ppxIdleTaskStackBuffer, 
								   uint32_t *pulIdleTaskStackSize)
{
	*ppxIdleTaskTCBBuffer=&Idle_Task_TCB;/* 任务控制块内存 */
	*ppxIdleTaskStackBuffer=Idle_Task_Stack;/* 任务堆栈内存 */
	*pulIdleTaskStackSize=configMINIMAL_STACK_SIZE;/* 任务堆栈大小 */
}
```

