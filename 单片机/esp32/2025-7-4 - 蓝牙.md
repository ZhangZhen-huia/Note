# 蓝牙发展史

![image-20250713095728181](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507130957237.png)

# 蓝牙协议栈

[蓝牙学习一（简介）_蓝牙profile-CSDN博客](https://blog.csdn.net/qq_26226375/article/details/127906179?spm=1001.2014.3001.5501)

![image-20250713101544647](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507131015719.png)

上图为**Nordic的架构**

PHY：物理层，用来指定无线频段，调制解调方式，PHY层直接决定了蓝牙的功耗和灵敏度等射频特性

LL：链路层，LL层是整个协议的核心，负责接收或者发送数据，对于数据的解析则是GAP或者ATT来负责

HCI：可选择的，用来规范两者之间的通讯协议和通信命令等

GAP：通用访问规范文件，对LL层的有效数据包进行解析，目前主要用来进行**广播**，**扫描**和**发起连接**

L2CAP：逻辑链路控制和适配协议，对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理

SMP：加密管理协议，SMP用来管理BLE连接的加密和安全

ATT：属性协议，ATT层用来定义用户命令及命令操作的数据，BLE引入了attribute概念，用来描述一条一条的数据。Attrubute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层

GATT：通用属性配置文件，GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑。但互联互通就会出问题

> **ATT和GATT的关系就像车辆和交通规则一样**。ATT就是车辆，而GATT就是规范车辆该如何行驶的交通规则。只有GATT存在的时候，多个ATT见面才知道该如何形式，到底是拐弯让直行还是坐车道超车



## 蓝牙控制器

由硬件实现，包括BLE控制器，BR/EDR控制器和5.3版本删除的AMP控制器

![image-20250713101829867](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507131018913.png)

## 蓝牙主机

主机是由软件实现的

![image-20250713102156450](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507131021496.png)

## 专业术语

- GAP: 通用访问
- GATT/ATT: 通用属性
- SMP: 安全管理
- SDP: 服务发现
- L2CAP: 链路管理与适配
- HCI: 主机控制接口
- DM: 设备管理
- LM: 链路管理
- LC: 链路控制
- PHY: 物理层

## esp32的蓝牙

esp使用的是谷歌开发的bluedriod蓝牙协议栈

# 蓝牙GAP

[蓝牙低功耗（BLE）：GAP详解：设备发现、连接与安全配置-CSDN博客](https://blog.csdn.net/qq_26226375/article/details/128017160)

generic access profile **通用访问规范**

GAP层与应用层紧密相连，也就是蓝牙协议栈的栈顶，目前主要用来进行广播、扫描和发起连接。GAP保证了不同的设备可以互相发现对方并建立连接

GAP就好比一种语言，大家都说同一种语言才能相互听懂，相互知道说的是什么。否则就只能大眼瞪小眼

## GAP定义了四种角色

- 广播者：用于只通过广播发送数据的应用。只是广播信息让接收者发现自己，但是不可用被连接，比如苹果的iBeacon
- 观察者：只是进行扫描，监听广播的数据，不能建立连接，比如BLE Sniffer蓝牙协议分析仪
- 外围设备：广播数据，可以被连接，被连接后成为从机
- 中央设备：接收到广播的信息后，可以建立连接，在通信中作为主机，支持三个同时连接

## GAP提供如下功能

- 广播：设置和获取广播参数，启动和停止广播，有idle、start、advertising和stop四个状态
- 扫描：设置和获取扫描参数，启动和停止扫描，有idle、start、scaning和stop四个状态
- 连接：设置，更新参数，创建终止连接
- 配对：设置参数，启动配对
- 密钥管理：根据设备地址和地址类型查找密钥，保存/加载绑定设备信息的密钥，解析random address

## Beacon信标广播

- Beacon是一种用于营销和定位的短距离无线通信蓝牙设备，是蓝牙低功耗协议中的外围设备
- 信标本质是一种**蓝牙广播**标准，该标准不是蓝牙技术联盟所制定的标准，它被称为“虚拟标准”
- Eddston是谷歌公司制定的标准，可以广播四种帧格式，自定义唯一的信标ID（UID）、广播网址（URL）、广播自身数据（E表示加密）（TLM/ETLM）、加密的临时标识符（EID）

UID：最多有128位，实际上只用到了16位或者32位，是在官方注册的

UUID：通用唯一标识符，最多128位，实际上用了16或者32位，这一个ID里面有公司, 对象特征值类型, 属性类型声明, 属性特征描述符, 属性服务, 计量单位, 协助标识符, 标准开发组织, 服务规范ID

## BLE广播包格式

![image-20250715173448476](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151734542.png)

- 访问地址分为两种
  - 广播接入地址：固定值，0x8E89BED6，在广播，扫描，发起连接时使用
  - 数据接入地址：随机值，不同的连接有不同的值，在建立连接后的两个设备间使用
- Header
  - Header_1：广播的类型，发送地址类型和接收地址类型，给0表示公开，给1表示随机
  - Header_2：表示长度，为6-37字节，不包含3个字节的CRC检验位，最少6个字节是因为PDU里面有6个字节的自身地址，最后的有效载荷才是真正的广播数据
- AD结构：包含类型，长度和数据

![image-20250715173749148](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151737214.png)

## EddyStone数据包格式

[ESP32S3蓝牙学习系列---Beacon信标之Eddystone-CSDN博客](https://blog.csdn.net/yplwrt/article/details/129107710)

![image-20250715174930491](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151749552.png)

Type：0x01表示flag，值为0x06，则对应下图，普通发现模式和不支持BR/EDR（不支持传统蓝牙）

![image-20250715175023946](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151750983.png)

Type：0x03

![image-20250715175458275](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151754304.png)

UUID：0xAA,0xFE表示谷歌

Type：0x16

![image-20250715175743589](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151757623.png)

EddyStone的数据格式有四种UID，URL，TLM，EID

> - UID：这是由三个字段组成的主要Eddystone框架，即命名空间标识符（10byte），实例标识符（6byte）和功率校准（1byte）。他将有助于将字段直接配置到BLE信标中，实例标识符旨在唯一地表示一个信标，因为他们具有不同的实例ID，功率校准字段用于根据RSSI帮助计算移动设备和Eddystone信标之间的距离。
> - URL：该框架的主要目的是提供一种传输URL的方法，以便蓝牙低功耗扫描仪设备检测和发现它，然后BLE设备将连接收到并为用户显示正确的网页。BLE信标发送Eddystone-URL资源，智能手机等移动设备在检测到信标数据后立即在浏览器中自动打开网址。同时该框架提供类似于Eddystone-UID的功率校准功能。
>   - ![image-20250715180223549](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151802585.png)
> - TLM：Eddystone-TML 框架的主要是提供关于Eddystone的健康状况的完整报告。当前温度, 当前电池电量, 正常运行时间 (信标已通电的秒数), 和 PduCount (信标在最后一次供电后部署的广告数据包的数量).
> - EID：这是负责小工具安全和隐私的框架



## 示例

![image-20250715182509645](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151825704.png)

![](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507142203871.png)

![image-20250715180406758](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151804816.png)

[GAP API - ESP32 - — ESP-IDF 编程指南 v5.4.2 文档](https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/api-reference/bluetooth/esp_gap_ble.html)

### Beacon扫描

```c
/*
 * SPDX-FileCopyrightText: 2021-2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Unlicense OR CC0-1.0
 */


/****************************************************************************
*
* This file is used for eddystone receiver.
*
****************************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <inttypes.h>

#include "esp_bt.h"
#include "nvs_flash.h"
#include "esp_log.h"
#include "esp_bt_defs.h"
#include "esp_bt_main.h"
#include "esp_gatt_defs.h"
#include "esp_gattc_api.h"
#include "esp_gap_ble_api.h"
#include "freertos/FreeRTOS.h"

#include "esp_eddystone_protocol.h"
#include "esp_eddystone_api.h"

static const char* DEMO_TAG = "EDDYSTONE_DEMO";

/* declare static functions */
static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t* param);
static void esp_eddystone_show_inform(const esp_eddystone_result_t* res);

//扫描的参数设置
static esp_ble_scan_params_t ble_scan_params = {
    .scan_type              = BLE_SCAN_TYPE_ACTIVE,  //扫描类型
    .own_addr_type          = BLE_ADDR_TYPE_PUBLIC,  //所有者的地址类型
    .scan_filter_policy     = BLE_SCAN_FILTER_ALLOW_ALL,
    .scan_interval          = 0x50,   //扫描间隔
    .scan_window            = 0x30,   //扫描的持续时间，小于扫描间隔
    .scan_duplicate         = BLE_SCAN_DUPLICATE_DISABLE  //是否过率重复包
};

static void esp_eddystone_show_inform(const esp_eddystone_result_t* res)
{
    switch(res->common.frame_type)
    {
        case EDDYSTONE_FRAME_TYPE_UID: {
            ESP_LOGI(DEMO_TAG, "Eddystone UID inform:");
            ESP_LOGI(DEMO_TAG, "Measured power(RSSI at 0m distance):%d dbm", res->inform.uid.ranging_data);
            ESP_LOGI(DEMO_TAG, "EDDYSTONE_DEMO: Namespace ID:0x");
            ESP_LOG_BUFFER_HEX(DEMO_TAG, res->inform.uid.namespace_id, 10);
            ESP_LOGI(DEMO_TAG, "EDDYSTONE_DEMO: Instance ID:0x");
            ESP_LOG_BUFFER_HEX(DEMO_TAG, res->inform.uid.instance_id, 6);
            break;
        }
        case EDDYSTONE_FRAME_TYPE_URL: {
            ESP_LOGI(DEMO_TAG, "Eddystone URL inform:");
            ESP_LOGI(DEMO_TAG, "Measured power(RSSI at 0m distance):%d dbm", res->inform.url.tx_power);
            ESP_LOGI(DEMO_TAG, "URL: %s", res->inform.url.url);
            break;
        }
        case EDDYSTONE_FRAME_TYPE_TLM: {
            ESP_LOGI(DEMO_TAG, "Eddystone TLM inform:");
            ESP_LOGI(DEMO_TAG, "version: %d", res->inform.tlm.version);
            ESP_LOGI(DEMO_TAG, "battery voltage: %d mV", res->inform.tlm.battery_voltage);
            ESP_LOGI(DEMO_TAG, "beacon temperature in degrees Celsius: %6.1f", res->inform.tlm.temperature);
            ESP_LOGI(DEMO_TAG, "adv pdu count since power-up: %" PRIu32, res->inform.tlm.adv_count);
            ESP_LOGI(DEMO_TAG, "time since power-up: %" PRIu32 " s", (res->inform.tlm.time)/10);
            break;
        }
        default:
            break;
    }
}

static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t* param)
{
    esp_err_t err;

    switch(event)
    {
            //扫描参数设置完成事件
        case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: {
            uint32_t duration = 0;//保持扫描的时间，单位为秒
            esp_ble_gap_start_scanning(duration);
            break;
        }
            //扫描开始完成事件
        case ESP_GAP_BLE_SCAN_START_COMPLETE_EVT: {
            if((err = param->scan_start_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
                ESP_LOGE(DEMO_TAG,"Scan start failed: %s", esp_err_to_name(err));
            }
            else {
                ESP_LOGI(DEMO_TAG,"Start scanning...");
            }
            break;
        }
            //扫描结果事件
        case ESP_GAP_BLE_SCAN_RESULT_EVT: {
            esp_ble_gap_cb_param_t* scan_result = (esp_ble_gap_cb_param_t*)param;
            switch(scan_result->scan_rst.search_evt)
            {
                    //搜索结果事件
                case ESP_GAP_SEARCH_INQ_RES_EVT: {
                    esp_eddystone_result_t eddystone_res;
                    memset(&eddystone_res, 0, sizeof(eddystone_res));
                    //解析广播包是否为EddyStone包
                    esp_err_t ret = esp_eddystone_decode(scan_result->scan_rst.ble_adv, scan_result->scan_rst.adv_data_len, &eddystone_res);
                    if (ret) {
                        // error:The received data is not an eddystone frame packet or a correct eddystone frame packet.
                        // just return
                        return;
                    } else {
                        // The received adv data is a correct eddystone frame packet.
                        // Here, we get the eddystone information in eddystone_res, we can use the data in res to do other things.
                        // For example, just print them:
                        ESP_LOGI(DEMO_TAG, "--------Eddystone Found----------");
                        ESP_LOG_BUFFER_HEX("EDDYSTONE_DEMO: Device address:", scan_result->scan_rst.bda, ESP_BD_ADDR_LEN);
                        ESP_LOGI(DEMO_TAG, "RSSI of packet:%d dbm", scan_result->scan_rst.rssi);
                        esp_eddystone_show_inform(&eddystone_res);
                    }
                    break;
                }
                default:
                    break;
            }
            break;
        }
            //扫描停止完成事件
        case ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT:{
            if((err = param->scan_stop_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
                ESP_LOGE(DEMO_TAG,"Scan stop failed: %s", esp_err_to_name(err));
            }
            else {
                ESP_LOGI(DEMO_TAG,"Stop scan successfully");
            }
            break;
        }
        default:
            break;
    }
}

void esp_eddystone_appRegister(void)
{
    esp_err_t status;

    ESP_LOGI(DEMO_TAG,"Register callback");

    /*<! register the scan callback function to the gap module */
    if((status = esp_ble_gap_register_callback(esp_gap_cb)) != ESP_OK) {
        ESP_LOGE(DEMO_TAG,"gap register error: %s", esp_err_to_name(status));
        return;
    }
}

void esp_eddystone_init(void)
{
    esp_bluedroid_init();
    esp_bluedroid_enable();
    esp_eddystone_appRegister();
}

void app_main(void)
{
    ESP_ERROR_CHECK(nvs_flash_init());

    //释放经典蓝牙控制器
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    //初始化并开启BLE蓝牙控制器
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    esp_bt_controller_init(&bt_cfg);
    esp_bt_controller_enable(ESP_BT_MODE_BLE);

    //eddystone初始化
    esp_eddystone_init();

    /*设置扫描参数 */
    esp_ble_gap_set_scan_params(&ble_scan_params);
}
```

### 广播

```c
//UUID
static uint8_t adv_service_uuid128[16] = {
    /* LSB <--------------------------------------------------------------------------------> MSB */
    //first uuid, 16bit, [12],[13] is the value
    0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0xAA, 0xFE, 0x00, 0x00,

};

//广播数据EddyStones帧参数
/* 广播/扫描响应里要携带的「数据内容」 */
static esp_ble_adv_data_t adv_data = {
    .set_scan_rsp        = false,          // 这些数据放在「普通广播包」里，而不是扫描响应包
    .include_name        = true,           // 广播包里要包含「设备完整名称」
    .include_txpower     = true,           // 广播包里要包含「发射功率」字段（方便客户端估算距离）
    .min_interval        = 0x0006,         // 建议中央设备在建立连接后使用的最小连接间隔
                                           // 0x0006 * 1.25 ms = 7.5 ms
    .max_interval        = 0x000C,         // 建议最大连接间隔
                                           // 0x000C * 1.25 ms = 15 ms
    .appearance          = 0x00,           // 外观类型（0x00 = 未知/通用）
    .manufacturer_len    = 0,              // 厂商自定义数据长度；0 表示不携带
    .p_manufacturer_data = NULL,           // 指向厂商数据的指针
    .service_data_len    = 0,              // Service Data 长度；0 表示不携带
    .p_service_data      = NULL,           // 指向 Service Data 的指针
    .service_uuid_len    = 16,             // 128-bit Service UUID 长度（字节数）
    .p_service_uuid      = adv_service_uuid128, // 指向 128-bit Service UUID 数组
    .flag                = (ESP_BLE_ADV_FLAG_GEN_DISC |  // 标志位：通用可发现模式
                            ESP_BLE_ADV_FLAG_BREDR_NOT_SPT), // 同时声明「不支持经典蓝牙（BR/EDR）」
};

// 控制「广播行为/时序」的参数 广播包Advertising Packet参数
static esp_ble_adv_params_t adv_params = {
    .adv_int_min        = 0x20,            // 最小广播间隔
                                           // 0x20 * 0.625 ms = 20 ms
    .adv_int_max        = 0x40,            // 最大广播间隔
                                           // 0x40 * 0.625 ms = 40 ms
    .adv_type           = ADV_TYPE_IND,    // 广播类型：通用可连接、可扫描的「ADV_IND」
    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC, // 使用芯片的公共地址（Public Address）
    .channel_map        = ADV_CHNL_ALL,    // 在 37/38/39 三个广播信道全部发送
    .adv_filter_policy  = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, // 不启用白名单，任何设备都可扫描/连接
    
    //下面两个只在 定向广播（Directed Advertising）时才需要填写，普通广播可忽略
    //如果你想让外设立即被某个已配对手机连接，而不想让其它手机扫描到，就把广播类型设成 ADV_TYPE_DIRECT_IND，然后填这两字段
    //.peer_addr            = //目标设备的 6 字节蓝牙地址（BD_ADDR）
    //.peer_addr_type       = //上述地址的类型
};


eddystone_uid_t uid;

//这里的话，发送URL，TLM，EID都有对应的函数，返回值是服务数据的长度，然后配合上面的Beacon扫描就可以验证是否发送成功
int len = Eddystone_Set_UID(&uid, 10, (uint8_t *)"hello", (uint8_t *)"12345");
if(len == -1){
    ESP_LOGE("main", "get eddystone error");
    return;
}
adv_data.service_data_len = len;
adv_data.p_service_data = (uint8_t *)&uid;

esp_ble_gap_config_adv_data(&adv_data);
esp_ble_gap_start_advertising(&adv_params); //这一个函数最好放在回调函数里面，就是在如上面的函数esp_gap_cb里面，加一个广播参数设置完成事件

```

# 蓝牙GATT/ATT

- ATT它是处于L2CAP协议层与GATT之间的一层属性操作协议
- ATT基本属性：属性句柄（属性表下标索引），属性类型（由UUID定义），属性值以及访问权限
- ATT就相当于设备的数据库

- GATT通用属性配置文件，GATT层是传输真正数据的层，包括了一个数据传输和存储架构以及其基本操作
- GATT用来规范attribute（ATT）中的数据内容
- GATT定义了两种角色：服务端和客户端（server和client），一个设备可以同时成为客户端和服务端
- GATT可以进行交换配置, 发现对方设备服务和特性, 读写特征值, 特征值的通知和指示

![image-20250716175512855](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161755966.png)

## SPP串口透传

![image-20250716175555720](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161755828.png)

![](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161808340.png)

- 在蓝牙设备扫描结果查询中，**SDP（Service Discovery Protocol，服务发现协议）** 的核心作用是**帮助客户端设备发现并识别远程设备所支持的服务及其特性**，从而决定是否建立连接
- SDP 允许客户端在扫描到蓝牙设备后，进一步查询该设备支持哪些服务（如音频传输、文件传输、打印服务等）。每个服务以“服务记录（Service Record）”的形式存在，包含服务类型、UUID、名称、所需协议等属性

![image-20250716181622041](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161816199.png)

![image-20250716182305586](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161823721.png)

![image-20250716182346005](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161823121.png)

## 服务特征属性表

### UUID

![image-20250716182530303](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161825400.png)

### 服务属性表

![image-20250716182843785](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161828907.png)

### 属性表

```c

/**
 * @brief attribute type added to the GATT server database
 */
typedef struct
{
    esp_attr_control_t      attr_control;                   //是否使用自动回复
    esp_attr_desc_t         att_desc;                       /*!< The attribute type */
} esp_gatts_attr_db_t;


typedef struct
{
    /**
     * @brief Controls who handles the response to Read/Write operations.
     *
     * - If set to @c ESP_GATT_RSP_BY_APP, the application is responsible for
     *   generating the response.
     * - If set to @c ESP_GATT_AUTO_RSP, the GATT stack will automatically generate
     *   the response.
     */
    uint8_t auto_rsp;
} esp_attr_control_t;

typedef struct
{
    uint16_t uuid_length;              //uuid长度
    uint8_t  *uuid_p;                  //uuid数据指针
    uint16_t perm;                     //客户端对声明的权限 
    uint16_t max_length;               //当前属性最大长度
    uint16_t length;                   //当前属性的实际长度
    uint8_t  *value;                   //属性数据指针
} esp_attr_desc_t;


//BLE GATT Server 中定义一个完整的 GATT 数据库表（attribute database），也就是告诉蓝牙协议栈：
//“我要提供哪些服务（Service）、特征（Characteristic）、描述符（Descriptor），以及它们的权限、初始值、UUID 等信息。”
static const esp_gatts_attr_db_t spp_gatt_db[SPP_IDX_NB] =
{
    //是否自动回复，uuid长度，uuid指针，客户端对声明的权限，最大长度，当前长度，数据指针

    //SPP -  Service Declaration 0x2800 主要服务
    [SPP_IDX_SVC]                      	=
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ,
    sizeof(spp_service_uuid), sizeof(spp_service_uuid), (uint8_t *)&spp_service_uuid}},

    //SPP -  data receive characteristic Declaration 0x2803 定义一个接收数据的特征（客户端 → 服务端esp）。
    //是特征的声明（告诉客户端“我有个可读写特征”）
    [SPP_IDX_SPP_DATA_RECV_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}},

    //SPP -  data receive characteristic Value 
    //是特征的实际值（存储接收到的数据）
    [SPP_IDX_SPP_DATA_RECV_VAL]             	=
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_data_receive_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    SPP_DATA_MAX_LEN,sizeof(spp_data_receive_val), (uint8_t *)spp_data_receive_val}},

    //SPP -  data notify characteristic Declaration 声明特征值
    //定义一个发送数据的特征（服务端esp → 客户端），通过通知（Notify）方式
    //声明支持通知
    [SPP_IDX_SPP_DATA_NOTIFY_CHAR]  =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_notify}},

    //SPP -  data notify characteristic Value
    //实际发送给客户端的数据
    [SPP_IDX_SPP_DATA_NTY_VAL]   =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_data_notify_uuid, ESP_GATT_PERM_READ,
    SPP_DATA_MAX_LEN, sizeof(spp_data_notify_val), (uint8_t *)spp_data_notify_val}},

    //SPP -  data notify characteristic - Client Characteristic Configuration Descriptor
    //客户端配置描述符（CCCD），用于启用/禁用通知（客户端写 0x0001 开启通知）
    [SPP_IDX_SPP_DATA_NTF_CFG]         =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(uint16_t),sizeof(spp_data_notify_ccc), (uint8_t *)spp_data_notify_ccc}},

    //SPP -  command characteristic Declaration
    //定义一个命令特征（客户端 → 服务端ESP32），比如发送控制指令
    //这里是声明
    [SPP_IDX_SPP_COMMAND_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}},

    //SPP -  command characteristic Value
    //这里是接收到客户端的数据
    [SPP_IDX_SPP_COMMAND_VAL]                 =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_command_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    SPP_CMD_MAX_LEN,sizeof(spp_command_val), (uint8_t *)spp_command_val}},

    //SPP -  status characteristic Declaration
    //定义一个状态特征（服务端ESP32 → 客户端），通过通知上报设备状态（比如“已连接”“错误码”）
    //这里是声明有这样一的状态特征
    [SPP_IDX_SPP_STATUS_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_notify}},

    //SPP -  status characteristic Value
    //这里是存放状态数据的地方
    [SPP_IDX_SPP_STATUS_VAL]                 =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_status_uuid, ESP_GATT_PERM_READ,
    SPP_STATUS_MAX_LEN,sizeof(spp_status_val), (uint8_t *)spp_status_val}},

    //SPP -  status characteristic - Client Characteristic Configuration Descriptor
    //客户端特征配置描述符 CCCD，让客户端 开关通知
    //客户端写 0x0001 → 打开通知，ESP32 以后可主动发 notify（即状态数据）；
    //客户端写 0x0000 → 关闭通知。
    [SPP_IDX_SPP_STATUS_CFG]         =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(uint16_t),sizeof(spp_status_ccc), (uint8_t *)spp_status_ccc}},

    //支持心跳特征
#ifdef SUPPORT_HEARTBEAT
    //SPP -  Heart beat characteristic Declaration
    //特征声明，支持 读、写、通知（Read | Write | Notify） 三种操作
    [SPP_IDX_SPP_HEARTBEAT_CHAR]  =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write_notify}},

    //SPP -  Heart beat characteristic Value
    //特征值，一个双向数据槽，客户端可以随时写一段心跳数据表示我还或者，也可以读取当前心跳值
    [SPP_IDX_SPP_HEARTBEAT_VAL]   =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_heart_beat_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(spp_heart_beat_val), sizeof(spp_heart_beat_val), (uint8_t *)spp_heart_beat_val}},

    //SPP -  Heart beat characteristic - Client Characteristic Configuration Descriptor
    //客户端特征配置描述符 CCCD，让客户端 开关通知
    // 写 0x0001 → 打开 notify，ESP32 可定时把心跳值推给手机
    //写 0x0000 → 关闭 notify。
    [SPP_IDX_SPP_HEARTBEAT_CFG]         =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(uint16_t),sizeof(spp_data_notify_ccc), (uint8_t *)spp_heart_beat_ccc}},
#endif
};


//创建属性表，在gatts_profile_event_handler的ESP_GATTS_REG_EVT事件里面进行创建
esp_ble_gatts_create_attr_tab(spp_gatt_db, gatts_if, SPP_IDX_NB, SPP_SVC_INST_ID);
//创建完成后会进入ESP_GATTS_CREAT_ATTR_TAB_EVT事件，在gatts协议栈回调中
```



## 服务器示例

### 初始化

```c
void app_main(void)
{
    esp_err_t ret;
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    // 初始化flash
    ret = nvs_flash_init();
    //释放经典蓝牙控制器内存
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    //初始化蓝牙控制器
    ret = esp_bt_controller_init(&bt_cfg);
    //使能低功耗蓝牙控制器
    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    //初始化bluedroid蓝牙协议栈
    ret = esp_bluedroid_init();
    //开启bluedroid蓝牙协议栈
    ret = esp_bluedroid_enable();
    //注册回调，GAP事件回调，GATTS事件回调，GATTS_APP
    esp_ble_gatts_register_callback(gatts_event_handler);
    esp_ble_gap_register_callback(gap_event_handler);
    esp_ble_gatts_app_register(ESP_SPP_APP_ID);
    //创建任务
    spp_task_init();
    //设置最大传输量
    esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500);

    return;
}
```

### gap回调

```c
static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{
    esp_err_t err;
    ESP_LOGI(GATTS_TABLE_TAG, "GAP_EVT, event %d", event);

    switch (event) {
        //原始广播数据设置完成事件
    case ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT:
        //开启广播
        esp_ble_gap_start_advertising(&spp_adv_params);
        break;
        //开启广播完成事件
    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        //advertising start complete event to indicate advertising start successfully or failed
        if((err = param->adv_start_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTS_TABLE_TAG, "Advertising start failed: %s", esp_err_to_name(err));
        }
        break;
    default:
        break;
    }
}
```

### gatts协议栈回调

```c
static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    esp_ble_gatts_cb_param_t *p_data = (esp_ble_gatts_cb_param_t *) param;
    uint8_t res = 0xff;

    ESP_LOGI(GATTS_TABLE_TAG, "event = %x",event);
    switch (event) {
            //GATT Serve注册事件，由esp_ble_gatts_app_register触发
    	case ESP_GATTS_REG_EVT:
    	    ESP_LOGI(GATTS_TABLE_TAG, "%s %d", __func__, __LINE__);
        	esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME);

        	ESP_LOGI(GATTS_TABLE_TAG, "%s %d", __func__, __LINE__);
            //设置原始广播数据
        	esp_ble_gap_config_adv_data_raw((uint8_t *)spp_adv_data, sizeof(spp_adv_data));

            //创建属性表
        	ESP_LOGI(GATTS_TABLE_TAG, "%s %d", __func__, __LINE__);
        	esp_ble_gatts_create_attr_tab(spp_gatt_db, gatts_if, SPP_IDX_NB, SPP_SVC_INST_ID);
       	break;
            
        //GATT读事件，当远端 BLE 客户端（Client）想读取设备上的某个特征值（Characteristic）时触发。
       //esp_ble_gattc_read_char() 或 esp_ble_gattc_read_char_descr()触发
    	case ESP_GATTS_READ_EVT:
            res = find_char_and_desr_index(p_data->read.handle);//客户端想读取的 attribute handle
            //客户端想要读取 STATUS 特征值
            if(res == SPP_IDX_SPP_STATUS_VAL){
                //TODO:client read the status characteristic
                //可以调用esp_ble_gatts_send_response来回应
                //如果不调用 esp_ble_gatts_send_response()，客户端会 读超时（报错 ESP_GATT_READ_NOT_PERMIT 或 ESP_GATT_ERROR）
            }
       	 break;
         //GATT写入事件，用来接收并处理 BLE 客户端（Client）写特征值 的行为 esp_ble_gattc_write_char_descr后触发，也可以由客户端的ESP_GATTC_WRITE_CHAR_EVT事件触发（如果向服务端发送了写请求的话）
    	case ESP_GATTS_WRITE_EVT: {
    	    res = find_char_and_desr_index(p_data->write.handle);
            //判断是直接写入还是准备写入缓存 false是直接写入
            if(p_data->write.is_prep == false){
                ESP_LOGI(GATTS_TABLE_TAG, "ESP_GATTS_WRITE_EVT : handle = %d", res);
                //自定义“命令”特征值，客户端下发 控制命令 给服务端
                if(res == SPP_IDX_SPP_COMMAND_VAL){
                    uint8_t * spp_cmd_buff = NULL;
                    spp_cmd_buff = (uint8_t *)malloc((spp_mtu_size - 3) * sizeof(uint8_t));
                    if(spp_cmd_buff == NULL){
                        ESP_LOGE(GATTS_TABLE_TAG, "%s malloc failed", __func__);
                        break;
                    }
                    memset(spp_cmd_buff,0x0,(spp_mtu_size - 3));
                    memcpy(spp_cmd_buff,p_data->write.value,p_data->write.len);
                    xQueueSend(cmd_cmd_queue,&spp_cmd_buff,10/portTICK_PERIOD_MS);
                }
                //“数据”特征的 CCCD 描述符，客户端 打开/关闭数据通知
                else if(res == SPP_IDX_SPP_DATA_NTF_CFG){
                    if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x01)&&(p_data->write.value[1] == 0x00)){
                        enable_data_ntf = true;
                    }else if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x00)&&(p_data->write.value[1] == 0x00)){
                        enable_data_ntf = false;
                    }
                }
                //“心跳”特征的 CCCD 描述符，客户端 打开/关闭心跳通知
#ifdef SUPPORT_HEARTBEAT
                else if(res == SPP_IDX_SPP_HEARTBEAT_CFG){
                    if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x01)&&(p_data->write.value[1] == 0x00)){
                        enable_heart_ntf = true;
                    }else if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x00)&&(p_data->write.value[1] == 0x00)){
                        enable_heart_ntf = false;
                    }
                }
                //心跳值特征，客户端发来 心跳包数据
                else if(res == SPP_IDX_SPP_HEARTBEAT_VAL){
                    if((p_data->write.len == sizeof(heartbeat_s))&&(memcmp(heartbeat_s,p_data->write.value,sizeof(heartbeat_s)) == 0)){
                        heartbeat_count_num = 0;
                    }
                }
#endif
                //	数据接收特征，客户端发来 普通业务/串口数据
                else if(res == SPP_IDX_SPP_DATA_RECV_VAL){
#ifdef SPP_DEBUG_MODE
                    ESP_LOG_BUFFER_CHAR(GATTS_TABLE_TAG,(char *)(p_data->write.value),p_data->write.len);
#else
                    uart_write_bytes(UART_NUM_0, (char *)(p_data->write.value), p_data->write.len);
#endif
                }else{
                    //TODO:
                }
            }
            //准备写入缓存
            else if((p_data->write.is_prep == true)&&(res == SPP_IDX_SPP_DATA_RECV_VAL)){
                ESP_LOGI(GATTS_TABLE_TAG, "ESP_GATTS_PREP_WRITE_EVT : handle = %d", res);
                //写入缓存
                store_wr_buffer(p_data);
            }
      	 	break;
    	}
        //GATT执行写入事件
    	case ESP_GATTS_EXEC_WRITE_EVT:{
    	    ESP_LOGI(GATTS_TABLE_TAG, "ESP_GATTS_EXEC_WRITE_EVT");
            //判断是不是要写入
    	    if(p_data->exec_write.exec_write_flag){
    	        print_write_buffer();
    	        free_write_buffer();
    	    }
    	    break;
    	}
        
        //记录最大传输单元
    	case ESP_GATTS_MTU_EVT:
    	    spp_mtu_size = p_data->mtu.mtu;
    	    break;
    	case ESP_GATTS_CONF_EVT:
    	    break;
    	case ESP_GATTS_UNREG_EVT:
        	break;
    	case ESP_GATTS_DELETE_EVT:
        	break;
    	case ESP_GATTS_START_EVT:
        	break;
    	case ESP_GATTS_STOP_EVT:
        	break;
            
        //连接事件
    	case ESP_GATTS_CONNECT_EVT:
    	    spp_conn_id = p_data->connect.conn_id;
    	    spp_gatts_if = gatts_if;
    	    is_connected = true;
            //拷贝对方蓝牙地址
    	    memcpy(&spp_remote_bda,&p_data->connect.remote_bda,sizeof(esp_bd_addr_t));
            
            //发送心跳队列
#ifdef SUPPORT_HEARTBEAT
    	    uint16_t cmd = 0;
            xQueueSend(cmd_heartbeat_queue,&cmd,10/portTICK_PERIOD_MS);
#endif
        	break;
            
            //GATTS断开连接事件，当远端 BLE 客户端主动断开连接 或 连接异常丢失 时触发
    	case ESP_GATTS_DISCONNECT_EVT:
            spp_mtu_size = 23;
    	    is_connected = false;
    	    enable_data_ntf = false;
#ifdef SUPPORT_HEARTBEAT
    	    enable_heart_ntf = false;
    	    heartbeat_count_num = 0;
#endif
            //开始广播
    	    esp_ble_gap_start_advertising(&spp_adv_params);
    	    break;
    	case ESP_GATTS_OPEN_EVT:
    	    break;
    	case ESP_GATTS_CANCEL_OPEN_EVT:
    	    break;
    	case ESP_GATTS_CLOSE_EVT:
    	    break;
    	case ESP_GATTS_LISTEN_EVT:
    	    break;
    	case ESP_GATTS_CONGEST_EVT:
    	    break;
        
        //创建属性表完成事件
    	case ESP_GATTS_CREAT_ATTR_TAB_EVT:{
    	    ESP_LOGI(GATTS_TABLE_TAG, "The number handle =%x",param->add_attr_tab.num_handle);
    	    if (param->add_attr_tab.status != ESP_GATT_OK){
    	        ESP_LOGE(GATTS_TABLE_TAG, "Create attribute table failed, error code=0x%x", param->add_attr_tab.status);
    	    }
    	    else if (param->add_attr_tab.num_handle != SPP_IDX_NB){
    	        ESP_LOGE(GATTS_TABLE_TAG, "Create attribute table abnormally, num_handle (%d) doesn't equal to HRS_IDX_NB(%d)", param->add_attr_tab.num_handle, SPP_IDX_NB);
    	    }
    	    else {
                //esp_ble_gatts_create_attr_tab() 或 esp_ble_gatts_start_service() 被调用后，
                // ESP-IDF 会把上面的模板（即我们自己写的GATT 数据库表）实例化成一张真正的“属性表”：
                // 每个条目得到一个16-bit 句柄 (handle) —— 从 0x0001 开始连续编号；
                // 条目顺序与模板一致：先 Service 声明 → Char 声明 → Char Value → CCCD …
                // 运行时保存在 RAM 中，客户端以后就用这些 handle 去访问 。
                // 把协议栈生成的 GATT 属性句柄保存下来，后续读写通知都要靠这些句柄来定位。
    	        memcpy(spp_handle_table, param->add_attr_tab.handles, sizeof(spp_handle_table));
                //开始GATTS服务
    	        esp_ble_gatts_start_service(spp_handle_table[SPP_IDX_SVC]);
    	    }
    	    break;
    	}
    	default:
    	    break;
    }
}
```

### gatts回调

```c
static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    ESP_LOGI(GATTS_TABLE_TAG, "EVT %d, gatts if %d", event, gatts_if);

    /* If event is register event, store the gatts_if for each profile */
    if (event == ESP_GATTS_REG_EVT) {
        if (param->reg.status == ESP_GATT_OK) {
            spp_profile_tab[SPP_PROFILE_APP_IDX].gatts_if = gatts_if;
        } else {
            ESP_LOGI(GATTS_TABLE_TAG, "Reg app failed, app_id %04x, status %d",param->reg.app_id, param->reg.status);
            return;
        }
    }

    do {
        int idx;
        for (idx = 0; idx < SPP_PROFILE_NUM; idx++) {
            if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
                    gatts_if == spp_profile_tab[idx].gatts_if) {
                if (spp_profile_tab[idx].gatts_cb) {
                    spp_profile_tab[idx].gatts_cb(event, gatts_if, param);
                }
            }
        }
    } while (0);
}

```

## 客户端示例

### 初始化

```c
void ble_client_appRegister(void)
{
    esp_err_t status;
    char err_msg[20];

    ESP_LOGI(GATTC_TAG, "register callback");

    //注册gap，gatt回调，gatt应用
    //register the scan callback function to the gap module
    if ((status = esp_ble_gap_register_callback(esp_gap_cb)) != ESP_OK) {
        ESP_LOGE(GATTC_TAG, "gap register error: %s", esp_err_to_name_r(status, err_msg, sizeof(err_msg)));
        return;
    }
    //register the callback function to the gattc module
    if ((status = esp_ble_gattc_register_callback(esp_gattc_cb)) != ESP_OK) {
        ESP_LOGE(GATTC_TAG, "gattc register error: %s", esp_err_to_name_r(status, err_msg, sizeof(err_msg)));
        return;
    }
    esp_ble_gattc_app_register(PROFILE_APP_ID);

    //配置最大传输单元
    esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(200);
    if (local_mtu_ret){
        ESP_LOGE(GATTC_TAG, "set local  MTU failed: %s", esp_err_to_name_r(local_mtu_ret, err_msg, sizeof(err_msg)));
    }

    //创建任务，队列
    cmd_reg_queue = xQueueCreate(10, sizeof(uint32_t));
    xTaskCreate(spp_client_reg_task, "spp_client_reg_task", 2048, NULL, 10, NULL);

#ifdef SUPPORT_HEARTBEAT
    cmd_heartbeat_queue = xQueueCreate(10, sizeof(uint32_t));
    xTaskCreate(spp_heart_beat_task, "spp_heart_beat_task", 2048, NULL, 10, NULL);
#endif
}


void app_main(void)
{
    esp_err_t ret;
	nvs_flash_init();
    
    //释放经典蓝牙控制器内存
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    
    //配置，初始化，启动低功耗蓝牙控制器
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&bt_cfg);
    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    
    //初始,使能BlueDroid
    ret = esp_bluedroid_init();
    ret = esp_bluedroid_enable();


    //注册客户端APP
    ble_client_appRegister();
    spp_uart_init();
}

```

### gap回调

```c
static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{
    uint8_t *adv_name = NULL;
    uint8_t adv_name_len = 0;
    esp_err_t err;

    switch(event){
        
    //设置扫描参数完成事件
    case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: {
        if((err = param->scan_param_cmpl.status) != ESP_BT_STATUS_SUCCESS){
            ESP_LOGE(GATTC_TAG, "Scan param set failed: %s", esp_err_to_name(err));
            break;
        }
        //the unit of the duration is second
        uint32_t duration = 0xFFFF;
        ESP_LOGI(GATTC_TAG, "Enable Ble Scan:during time %04" PRIx32 " minutes.",duration);
        //开始扫描
        esp_ble_gap_start_scanning(duration);
        break;
    }
    //开始扫描完成事件
    case ESP_GAP_BLE_SCAN_START_COMPLETE_EVT:
        //scan start complete event to indicate scan start successfully or failed
        if ((err = param->scan_start_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTC_TAG, "Scan start failed: %s", esp_err_to_name(err));
            break;
        }
        ESP_LOGI(GATTC_TAG, "Scan start successfully");
        break;
    //停止扫描完成事件
    case ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT:
        if ((err = param->scan_stop_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTC_TAG, "Scan stop failed: %s", esp_err_to_name(err));
            break;
        }
        ESP_LOGI(GATTC_TAG, "Scan stop successfully");
        //如果还没有连接
        if (is_connect == false) {
            ESP_LOGI(GATTC_TAG, "Connect to the remote device.");
            esp_ble_gatt_creat_conn_params_t creat_conn_params = {0};
            //把最后一次扫描结果里的设备地址作为连接目标
            memcpy(&creat_conn_params.remote_bda, scan_rst.scan_rst.bda,ESP_BD_ADDR_LEN);
            creat_conn_params.remote_addr_type = scan_rst.scan_rst.ble_addr_type;
            creat_conn_params.own_addr_type = BLE_ADDR_TYPE_PUBLIC;
            creat_conn_params.is_direct = true;
            creat_conn_params.is_aux = false;
            creat_conn_params.phy_mask = 0x0;
            //建立连接
            esp_ble_gattc_enh_open(gl_profile_tab[PROFILE_APP_ID].gattc_if,
                                &creat_conn_params);
        }
        break;
    //扫描结果事件，只要收到任何广播包/扫描响应就会触发
    case ESP_GAP_BLE_SCAN_RESULT_EVT: {
        esp_ble_gap_cb_param_t *scan_result = (esp_ble_gap_cb_param_t *)param;
        switch (scan_result->scan_rst.search_evt) {

        //子事件：每发现一个新设备就会触发
        case ESP_GAP_SEARCH_INQ_RES_EVT:
                //打印设备地址和广播长度
            ESP_LOG_BUFFER_HEX(GATTC_TAG, scan_result->scan_rst.bda, 6);
            ESP_LOGI(GATTC_TAG, "Searched Adv Data Len %d, Scan Response Len %d", scan_result->scan_rst.adv_data_len, scan_result->scan_rst.scan_rsp_len);
           
            //获取远程服务端的名字和长度
            adv_name = esp_ble_resolve_adv_data_by_type(scan_result->scan_rst.ble_adv,
                                                        scan_result->scan_rst.adv_data_len + scan_result->scan_rst.scan_rsp_len,
                                                        ESP_BLE_AD_TYPE_NAME_CMPL,
                                                        &adv_name_len);
            ESP_LOGI(GATTC_TAG, "Searched Device Name Len %d", adv_name_len);
            ESP_LOG_BUFFER_CHAR(GATTC_TAG, adv_name, adv_name_len);
            ESP_LOGI(GATTC_TAG, " ");
            //对比
            if (adv_name != NULL) {
                if ( strncmp((char *)adv_name, device_name, adv_name_len) == 0) {
                    memcpy(&(scan_rst), scan_result, sizeof(esp_ble_gap_cb_param_t));
                    esp_ble_gap_stop_scanning();//停止扫描
                }
            }
            break;
        case ESP_GAP_SEARCH_INQ_CMPL_EVT:
            break;
        default:
            break;
        }
        break;
    }
    //停止广播完成事件
    case ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:
        if ((err = param->adv_stop_cmpl.status) != ESP_BT_STATUS_SUCCESS){
            ESP_LOGE(GATTC_TAG, "Adv stop failed: %s", esp_err_to_name(err));
        }else {
            ESP_LOGI(GATTC_TAG, "Stop adv successfully");
        }
        break;
    default:
        break;
    }
}

```

### gattc协议栈回调

```c
static void gattc_profile_event_handler(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param)
{
    esp_ble_gattc_cb_param_t *p_data = (esp_ble_gattc_cb_param_t *)param;

    switch (event) {
        //注册 GATT 客户端成功后，开始扫描
    case ESP_GATTC_REG_EVT:
        ESP_LOGI(GATTC_TAG, "REG EVT, set scan params");
        esp_ble_gap_set_scan_params(&ble_scan_params);
        break;
        //连接成功事件
    case ESP_GATTC_CONNECT_EVT:
        ESP_LOGI(GATTC_TAG, "ESP_GATTC_CONNECT_EVT: conn_id=%d, gatt_if = %d", spp_conn_id, gattc_if);
        ESP_LOGI(GATTC_TAG, "REMOTE BDA:");
        ESP_LOG_BUFFER_HEX(GATTC_TAG, gl_profile_tab[PROFILE_APP_ID].remote_bda, sizeof(esp_bd_addr_t));
        
        //记录
        spp_gattc_if = gattc_if;
        is_connect = true;
        spp_conn_id = p_data->connect.conn_id;
        //记录设备地址
        memcpy(gl_profile_tab[PROFILE_APP_ID].remote_bda, p_data->connect.remote_bda, sizeof(esp_bd_addr_t));
     	//对服务进行搜索, 进入ESP_GATTC_SEARCH_RES_EVT
        esp_ble_gattc_search_service(spp_gattc_if, spp_conn_id, &spp_service_uuid);
        break;
        //断开连接事件
    case ESP_GATTC_DISCONNECT_EVT:
        ESP_LOGI(GATTC_TAG, "disconnect");
        //释放资源，重新开始扫描
        free_gattc_srv_db();
        esp_ble_gap_start_scanning(SCAN_ALL_THE_TIME);
        break;
        
    //每找到一个服务触发一次
    case ESP_GATTC_SEARCH_RES_EVT:
        ESP_LOGI(GATTC_TAG, "ESP_GATTC_SEARCH_RES_EVT: start_handle = %d, end_handle = %d, UUID:0x%04x",p_data->search_res.start_handle,p_data->search_res.end_handle,p_data->search_res.srvc_id.uuid.uuid.uuid16);
        //记录服务端的Handle数据
        spp_srv_start_handle = p_data->search_res.start_handle;
        spp_srv_end_handle = p_data->search_res.end_handle;
        break;
    
    //全部搜索完成触发一次
    case ESP_GATTC_SEARCH_CMPL_EVT:
        ESP_LOGI(GATTC_TAG, "SEARCH_CMPL: conn_id = %x, status %d", spp_conn_id, p_data->search_cmpl.status);
        //发送最大传输单元，之后进入ESP_GATTC_CFG_MTU_EVT事件
        esp_ble_gattc_send_mtu_req(gattc_if, spp_conn_id);
        break;
            
        //注册通知事件，esp_ble_gattc_register_for_notify()后触发
    case ESP_GATTC_REG_FOR_NOTIFY_EVT: {
        ESP_LOGI(GATTC_TAG,"Index = %d,status = %d,handle = %d",cmd, p_data->reg_for_notify.status, p_data->reg_for_notify.handle);
        if(p_data->reg_for_notify.status != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG, "ESP_GATTC_REG_FOR_NOTIFY_EVT, status = %d", p_data->reg_for_notify.status);
            break;
        }
        //写入服务端的客户端配置特征值，使能通知，会触发ESP_GATTS_WRITE_EVT事件
        uint16_t notify_en = 1;
        esp_ble_gattc_write_char_descr(
                spp_gattc_if,
                spp_conn_id,
                (db+cmd+1)->attribute_handle,
                sizeof(notify_en),
                (uint8_t *)&notify_en,
                ESP_GATT_WRITE_TYPE_RSP,
                ESP_GATT_AUTH_REQ_NONE);

        break;
    }
    //收到通知事件，服务端 主动推送 Notification（无确认)时触发
    case ESP_GATTC_NOTIFY_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_NOTIFY_EVT");
        notify_event_handler(p_data);
        break;
            
    //读特征值事件，esp_ble_gattc_read_char()后会触发ESP_GATTS_READ_EVT事件，然后esp_ble_gatts_send_response会触发该事件
    case ESP_GATTC_READ_CHAR_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_READ_CHAR_EVT");
        break;
    //写特征值事件，esp_ble_gattc_write_char()触发
    case ESP_GATTC_WRITE_CHAR_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_WRITE_CHAR_EVT:status = %d,handle = %d", param->write.status, param->write.handle);
        if(param->write.status != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG, "ESP_GATTC_WRITE_CHAR_EVT, error status = %d", p_data->write.status);
            break;
        }
        break;
    case ESP_GATTC_PREP_WRITE_EVT:
        break;
    case ESP_GATTC_EXEC_EVT:
        break;
            
    //写入客户端配置特征值完成事件，ESP_GATTC_WRITE_DESCR_EVT 是“打开一个通知开关后的回调”；在这里用队列把下一个特征索引发出去，实现 DATA → STATUS → HEARTBEAT 的串行注册，直到全部启用通知
    case ESP_GATTC_WRITE_DESCR_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_WRITE_DESCR_EVT: status =%d,handle = %d", p_data->write.status, p_data->write.handle);
        if(p_data->write.status != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG, "ESP_GATTC_WRITE_DESCR_EVT, error status = %d", p_data->write.status);
            break;
        }
        switch(cmd){
            //注册DATA通知
        case SPP_IDX_SPP_DATA_NTY_VAL:
            cmd = SPP_IDX_SPP_STATUS_VAL;
            xQueueSend(cmd_reg_queue, &cmd,10/portTICK_PERIOD_MS);
            break;
            //注册STATUS通知
        case SPP_IDX_SPP_STATUS_VAL:
#ifdef SUPPORT_HEARTBEAT
            cmd = SPP_IDX_SPP_HEARTBEAT_VAL;
            xQueueSend(cmd_reg_queue, &cmd, 10/portTICK_PERIOD_MS);
#endif
            break;
#ifdef SUPPORT_HEARTBEAT
            //注册 HEARTBEAT 通知
        case SPP_IDX_SPP_HEARTBEAT_VAL:
            xQueueSend(cmd_heartbeat_queue, &cmd, 10/portTICK_PERIOD_MS);
            break;
#endif
        default:
            break;
        };
        break;
       
    //配置最大传输单元事件
    case ESP_GATTC_CFG_MTU_EVT:
        if(p_data->cfg_mtu.status != ESP_OK){
            break;
        }
        ESP_LOGI(GATTC_TAG,"+MTU:%d", p_data->cfg_mtu.mtu);
            
        //记录服务端发来的最大传输单元
        spp_mtu_size = p_data->cfg_mtu.mtu;

        //创建一个数据库，与服务端相比没有声明的枚举
        db = (esp_gattc_db_elem_t *)malloc(count*sizeof(esp_gattc_db_elem_t));
        if(db == NULL){
            ESP_LOGE(GATTC_TAG,"%s:malloc db failed",__func__);
            break;
        }
        //获取数据库
        if(esp_ble_gattc_get_db(spp_gattc_if, spp_conn_id, spp_srv_start_handle, spp_srv_end_handle, db, &count) != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG,"%s:get db failed",__func__);
            break;
        }
        if(count != SPP_IDX_NB){
            ESP_LOGE(GATTC_TAG,"%s:get db count != SPP_IDX_NB, count = %d, SPP_IDX_NB = %d",__func__,count,SPP_IDX_NB);
            break;
        }
        //根据类型打印数据库
        for(int i = 0;i < SPP_IDX_NB;i++){
            switch((db+i)->type){
            case ESP_GATT_DB_PRIMARY_SERVICE:
                ESP_LOGI(GATTC_TAG,"attr_type = PRIMARY_SERVICE,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_SECONDARY_SERVICE:
                ESP_LOGI(GATTC_TAG,"attr_type = SECONDARY_SERVICE,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_CHARACTERISTIC:
                ESP_LOGI(GATTC_TAG,"attr_type = CHARACTERISTIC,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_DESCRIPTOR:
                ESP_LOGI(GATTC_TAG,"attr_type = DESCRIPTOR,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_INCLUDED_SERVICE:
                ESP_LOGI(GATTC_TAG,"attr_type = INCLUDED_SERVICE,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_ALL:
                ESP_LOGI(GATTC_TAG,"attr_type = ESP_GATT_DB_ALL,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            default:
                break;
            }
        }
        cmd = SPP_IDX_SPP_DATA_NTY_VAL;
        xQueueSend(cmd_reg_queue, &cmd, 10/portTICK_PERIOD_MS);
        break;
    case ESP_GATTC_SRVC_CHG_EVT:
        break;
    default:
        break;
    }
}
```

### gatts回调

```c
static void esp_gattc_cb(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param)
{
    ESP_LOGI(GATTC_TAG, "EVT %d, gattc if %d", event, gattc_if);

    /* If event is register event, store the gattc_if for each profile */
    if (event == ESP_GATTC_REG_EVT) {
        if (param->reg.status == ESP_GATT_OK) {
            gl_profile_tab[param->reg.app_id].gattc_if = gattc_if;
        } else {
            ESP_LOGI(GATTC_TAG, "Reg app failed, app_id %04x, status %d", param->reg.app_id, param->reg.status);
            return;
        }
    }
    /* If the gattc_if equal to profile A, call profile A cb handler,
     * so here call each profile's callback */
    do {
        int idx;
        for (idx = 0; idx < PROFILE_NUM; idx++) {
            if (gattc_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
                    gattc_if == gl_profile_tab[idx].gattc_if) {
                if (gl_profile_tab[idx].gattc_cb) {
                    gl_profile_tab[idx].gattc_cb(event, gattc_if, param);
                }
            }
        }
    } while (0);
}

```

## 实际使用

### 模型读写

![image-20250718150351308](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507181503505.png)

#### 服务器端

- 自定义一个UUID

  - ```c
    #define TEST_GATT_UUID_LED   0xABF6
    ```

- 定义特征读写权限

  - ```c
    ESP_GATT_CHAR_PROP_BIT_WRITE_NR//客户端写入数据后，不要求服务器回复确认
    ```

  - ```c
    static const uint8_t led_char_prop_read_write_notify = ESP_GATT_CHAR_PROP_BIT_READ|ESP_GATT_CHAR_PROP_BIT_WRITE_NR|ESP_GATT_CHAR_PROP_BIT_NOTIFY;
    ```

- 定义特征服务

  - ```c
    static const uint16_t test_led_uuid = TEST_GATT_UUID_LED;
    static const uint8_t  test_led_val[1] = {0x00};//状态
    static const uint8_t  test_led_ccc[2] = {0x00, 0x00};//客户端配置
    ```

- 添加蓝牙 GATT（Generic Attribute Profile）服务定义 的索引值，包括属性的声明, 值和描述符

  - ```c
    enum{
        SPP_IDX_SVC,
    
        SPP_IDX_SPP_DATA_RECV_CHAR,
        SPP_IDX_SPP_DATA_RECV_VAL,
    
        SPP_IDX_SPP_DATA_NOTIFY_CHAR,
        SPP_IDX_SPP_DATA_NTY_VAL,
        SPP_IDX_SPP_DATA_NTF_CFG,
    
        SPP_IDX_SPP_COMMAND_CHAR,
        SPP_IDX_SPP_COMMAND_VAL,
    
        SPP_IDX_SPP_STATUS_CHAR,
        SPP_IDX_SPP_STATUS_VAL,
        SPP_IDX_SPP_STATUS_CFG,
    
    #ifdef SUPPORT_HEARTBEAT
        SPP_IDX_SPP_HEARTBEAT_CHAR,
        SPP_IDX_SPP_HEARTBEAT_VAL,
        SPP_IDX_SPP_HEARTBEAT_CFG,
    #endif
    
    #ifdef SUPPORT_LED
        TEST_LED_CHAR,
        TEST_LED_VAL,
        TEST_LED_CFG,
    #endif
    
        SPP_IDX_NB,
    };
    ```

- 添加GATT数据表库

  - ```c
    #ifdef SUPPORT_LED
        [TEST_LED_CHAR] =                                   //0x2803    特征声明
        {{ESP_GATT_AUTO_RSP},{ESP_UUID_LEN_16,(uint8_t *)&character_declaration_uuid,ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
        CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE,(uint8_t*)&led_char_prop_read_write_notify}},
    
        [TEST_LED_VAL] =                                    //x0ABF6 自定义UUID
        {{ESP_GATT_AUTO_RSP},{ESP_UUID_LEN_16,(uint8_t *)&test_led_uuid,ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
        sizeof(uint8_t),sizeof(test_led_val),(uint8_t*)test_led_val}},
    
        [TEST_LED_CFG] =                                    //0x2902    客户端配置特征
        {{ESP_GATT_AUTO_RSP},{ESP_UUID_LEN_16,(uint8_t *)&character_client_config_uuid,ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
        sizeof(uint8_t),sizeof(test_led_ccc),(uint8_t*)test_led_ccc}}
    #endif
    
    ```

- 写入特征值，在gatts回调函数里面的ESP_GATTS_WRITE_EVT事件下面

  - esp_ble_gatts_set_attr_value函数来设定特征值

  - 写入完成后会进入ESP_GATTS_SET_ATTR_VAL_EVT这一个事件

  - ```c
    #ifdef SUPPORT_LED               
                    else if(res == TEST_LED_VAL)
                    {
                        //将要写入的值写入LED特征值
                        if(esp_ble_gatts_set_attr_value(p_data->write.handle,p_data->write.len,p_data->write.value) == ESP_OK)
                        {
                            //写入成功
                        }
                        else
                        {
                            //写入失败
                        }
                    }
    #endif  
    ```

    

- 编写写入特征值完成事件，在gatts回调中

  - ```c
    #ifdef SUPPORT_LED
            //设置属性值完成事件
            case ESP_GATTS_SET_ATTR_VAL_EVT:
            // 找到属性表下标
            res = find_char_and_desr_index(p_data->set_attr_val.attr_handle);
            
            if(res == TEST_LED_VAL)
            {
                xQueueSend(led_queue,&p_data->set_attr_val.status,10/portTICK_PERIOD_MS);
            }
            break;
    #endif
    ```

- 编写新的任务，比如led_task

  - ```c
    #ifdef SUPPORT_LED
    static QueueHandle_t led_queue = NULL;
    #endif
    
    #ifdef SUPPORT_LED
        led_queue = xQueueCreate(1, sizeof(uint8_t));
        xTaskCreate(led_task, "led_task", 2048, NULL, 10, NULL);
    #endif
    
    
    #ifdef SUPPORT_LED
    void led_task(void * arg)
    {
        const uint8_t *led_value = NULL;
        uint16_t len;
        uint8_t set_status = 0;
    
        //初始化LED
        /*
            todo
        */
    
    
        for(;;) {
            vTaskDelay(50 / portTICK_PERIOD_MS);
            //等待LED特征值被写入
            if(xQueueReceive(led_queue, &set_status, portMAX_DELAY)) {
                while(1){   
                    //写入特征值成功
                    if(set_status == ESP_GATT_OK)
                    {
                        if(esp_ble_gatts_get_attr_value(spp_handle_table[TEST_LED_VAL],&len,&led_value) != ESP_OK)
                        {
                            //获取LED特征值失败
                        }
                        else
                        {
                            //获取LED特征值成功
                            //控制LED函数
                        }
                    }
    #ifdef SUPPORT_NOTIFY
                    //如果通知或者指示标志位开启，就发送通知或者指示
                    //false 发送GATT通知，true发送GATT指示
                    if(flag == 1 || flag ==2)
                        esp_ble_gatts_send_indicate(spp_gatts_if,spp_conn_id,spp_handle_table[TEST_LED_VAL],sizeof(uint8_t),
                    led_value,flag == 1?false:true);
    
    #endif
    
                }
            }
        }
        vTaskDelete(NULL);
    }
    #endif
    
    ```

    

#### 客户端写入

- 添加服务定义 的索引值

  - ```c
    enum{
        SPP_IDX_SVC,
    
        SPP_IDX_SPP_DATA_RECV_VAL,
    
        SPP_IDX_SPP_DATA_NTY_VAL,
        SPP_IDX_SPP_DATA_NTF_CFG,
    
        SPP_IDX_SPP_COMMAND_VAL,
    
        SPP_IDX_SPP_STATUS_VAL,
        SPP_IDX_SPP_STATUS_CFG,
    
    #ifdef SUPPORT_HEARTBEAT
        SPP_IDX_SPP_HEARTBEAT_VAL,
        SPP_IDX_SPP_HEARTBEAT_CFG,
    #endif
    
    #ifdef SUPPORT_LED
        TEST_LED_VAL,
        TEST_LED_CFG,
    #endif
    
        SPP_IDX_NB,
    };
    ```

- 添加任务

  - ```c
    #ifdef SUPPORT_LED
        xTaskCreate(led_task, "led_task", 2048, NULL, 10, NULL);
    #endif
    
    #ifdef SUPPORT_LED
    void led_task(void* arg)
    {
        uint8_t status = 0;
        for(;;)
        {
            vTaskDelay(1000/portTICK_PERIOD_MS);
            //判断连接状态，数据库是否存在，以及权限
            if((is_connect == true) && (db != NULL) && ((db+TEST_LED_VAL)->properties & (ESP_GATT_CHAR_PROP_BIT_WRITE_NR | ESP_GATT_CHAR_PROP_BIT_WRITE)))
            {
                //写入LED特征值，这个会触发gattc的ESP_GATTC_WRITE_CHAR_EVT事件,然后如果向服务端发送写请求的话会触发ESP_GATTS_WRITE_EVT事件
                esp_ble_gattc_write_char(spp_gattc_if,spp_conn_id,(db+TEST_LED_VAL)->attribute_handle,sizeof(status),(uint8_t *)&status,ESP_GATT_WRITE_TYPE_RSP,ESP_GATT_AUTH_REQ_NONE);
    
                status++;
                status%=2;
                vTaskDelay(1000/portTICK_PERIOD_MS);
            }
        }
    }
    #endif
    ```

    

#### 客户端读取

- 在注册表里面添加自己的属性(下标, 描述符)

- 连接以后可以使用esp_ble_gattc_read_char函数读取特征值，这个函数会触发gatts的ESP_GATTS_READ_EVT事件，然后esp_ble_gatts_send_response会触发ESP_GATTC_READ_CHAR_EVT事件，表示读取完成事件，用户可以在该事件下进行读取数据的处理

  - ```c
    //判断是否读取成功
    if(p_data->read.status == ESP_GATT_OK)
    {
        //判断属性句柄句柄
        if(p_data->read.handle == (db+TEST_LED_VAL)->attribute_handle)//判断一下读取的属性
        {
            printf("read value = %d,len = %d\r\n",*p_data->read.value,p_data->read.value_len);
            memcpy(&read_status,p_data->read.value,p_data->read.value_len);
        }
    }
    ```

    

### 模型通知

![image-20250718160341908](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507181603104.png)

#### 服务端

- 编写ESP_GATTS_WRITE_EVT事件，由客户端的esp_ble_gattc_write_char_descr触发，获取客户端的通知请求

  - ```c
                    else if(res == TEST_LED_CFG)
                    {
                        flag = *p_data->write.value;
                    }
    ```

- 发送通知

  - ```c
    //如果通知或者指示标志位开启，就发送通知或者指示
    //false 发送GATT通知，true发送GATT指示
    if(flag == 1 || flag ==2)
    esp_ble_gatts_send_indicate(spp_gatts_if,spp_conn_id,spp_handle_table[TEST_LED_VAL],sizeof(uint8_t),
                        		led_value,flag == 1?false:true);
    ```

  - 后客户端会进入ESP_GATTC_NOTIFY_EVT这一个事件里面(需要注册这一个句柄的通知)

#### 客户端

- 使用esp_ble_gattc_register_for_notify()函数注册一个通知，绑定一个属性表的特征值

- 给某一个属性表的特征值注册一个通知, 之后就可以获这一个属性表的特征值的通知, 但是注册的时候不会对服务端进行通知, 需要在ESP_GATTC_REG_FOR_NOTIFY_EVT里面自己通知

  - ```c
    esp_ble_gattc_register_for_notify(spp_gattc_if,gl_profile_tab[PROFILE_APP_ID].remote_bda,
                                             (db+TEST_LED_VAL)->attribute_handle);
    ```

- 编写ESP_GATTC_REG_FOR_NOTIFY_EVT事件内容

  - 使用esp_ble_gattc_write_char_descr来向服务端发送请求

    ```c
    //写入服务端的客户端配置特征值，使能通知，会触发ESP_GATTS_WRITE_EVT事件            
    uint16_t notify_en = 1;
    esp_ble_gattc_write_char_descr(spp_gattc_if,
                                   spp_conn_id,
                                   (db+TEST_LED_CFG)->attribute_handle,
                                   sizeof(notify_en),
                                   (uint8_t *)&notify_en,
                                   ESP_GATT_WRITE_TYPE_RSP,
                                   ESP_GATT_AUTH_REQ_NONE);
    ```

- 服务端调用esp_ble_gatts_send_indicate函数触发ESP_GATTC_NOTIFY_EVT，在ESP_GATTC_NOTIFY_EVT事件里面处理收到的通知

  - ```c
    handle = p_data->notify.handle;  	
    	if(handle == ((db+TEST_LED_VAL)->attribute_handle))
        {
            if(p_data->notify.value_len == sizeof(uint8_t))
            {
                //获取通知
                flag = *(uint8_t *)p_data->notify.value;
            }
        }
    ```

## API函数

### 注册通知

```c
esp_err_t esp_ble_gattc_register_for_notify(esp_gatt_if_t gattc_if, esp_bd_addr_t server_bda, uint16_t handle);
//GATT 客户端接口编号,调用esp_ble_gattc_app_register(uint16_t app_id)函数之后会在ESP_GATTC_REG_EVT 里面返回一个gattc_if
//对端设备地址（MAC）
// 要监听通知的特征值句柄
```

### 服务器发送通知/指示

```c
esp_err_t esp_ble_gatts_send_indicate(esp_gatt_if_t gatts_if, uint16_t conn_id, uint16_t attr_handle, uint16_t value_len, uint8_t *value, bool need_confirm);
//会触发ESP_GATTC_NOTIFY_EVT事件 
//need_confirm 1为指示，0为通知

if(flag == 1 || flag ==2)
esp_ble_gatts_send_indicate(spp_gatts_if,spp_conn_id,spp_handle_table[TEST_LED_VAL],sizeof(uint8_t),
                    		led_value,flag == 1?false:true);
```

### 写入描述符数据

```c
esp_ble_gattc_write_char_descr(
    spp_gattc_if,	//客户端接口id
    spp_conn_id,	//连接id
    (db+TEST_LED_CFG)->attribute_handle,//描述符句柄（不是特征值句柄）
    sizeof(notify_en),//待写数据长度
    (uint8_t *)&notify_en,//待写数据
    ESP_GATT_WRITE_TYPE_RSP,//写类型：ESP_GATT_WRITE_TYPE_REQ / NO_RSP
    ESP_GATT_AUTH_REQ_NONE);//认证要求：ESP_GATT_AUTH_REQ_NONE 等

//最常用动作是 打开/关闭 notify 或 indicate
```

### 客户端读取

会触发ESP_GATTS_READ_EVT事件

esp_ble_gatts_send_response会触发ESP_GATTC_READ_CHAR_EVT事件

```c
esp_err_t esp_ble_gattc_read_char(esp_gatt_if_t gattc_if, uint16_t conn_id, uint16_t handle, esp_gatt_auth_req_t auth_req);
```

### 服务器回应

**GATT 服务端** 用来 **向客户端回送“响应”或“确认”** 的函数。

```c
esp_err_t esp_ble_gatts_send_response(
    esp_gatt_if_t gatts_if,     // 服务端接口 id
    uint16_t conn_id,           // 连接 id
    uint32_t trans_id,          // 事务 id（来自请求事件参数）
    esp_gatt_status_t status,   // 状态码：ESP_GATT_OK / ESP_GATT_ERROR …
    esp_gatt_rsp_t *rsp         // 响应数据（读操作需要填；写操作可 NULL）
);
```

### 获取服务

- 向远端 GATT 服务器 **发起服务发现请求**。
- 搜索完成后，会依次触发：
  - `ESP_GATTC_SEARCH_RES_EVT`：每找到一个服务触发一次。
  - `ESP_GATTC_SEARCH_CMPL_EVT`：全部搜索完成触发一次。

```c
esp_err_t esp_ble_gattc_search_service(
    esp_gatt_if_t gattc_if,      // GATT 客户端接口 ID
    uint16_t conn_id,            // 当前连接的 ID
    esp_bt_uuid_t *filter_uuid   // 指定要搜索的服务 UUID（可设为 NULL 搜索全部）
);
```

```c
    //每找到一个服务触发一次
    case ESP_GATTC_SEARCH_RES_EVT:
        ESP_LOGI(GATTC_TAG, "ESP_GATTC_SEARCH_RES_EVT: start_handle = %d, end_handle = %d, UUID:0x%04x",p_data->search_res.start_handle,p_data->search_res.end_handle,p_data->search_res.srvc_id.uuid.uuid.uuid16);
        //记录服务端的Handle数据
        spp_srv_start_handle = p_data->search_res.start_handle;
        spp_srv_end_handle = p_data->search_res.end_handle;
        break;
    
    //全部搜索完成触发一次
    case ESP_GATTC_SEARCH_CMPL_EVT:
        ESP_LOGI(GATTC_TAG, "SEARCH_CMPL: conn_id = %x, status %d", spp_conn_id, p_data->search_cmpl.status);
        //发送最大传输单元，之后进入ESP_GATTC_CFG_MTU_EVT事件
        esp_ble_gattc_send_mtu_req(gattc_if, spp_conn_id);
        break;
```

### 获取数据库

```c
esp_gatt_status_t esp_ble_gattc_get_db(
    esp_gatt_if_t gattc_if,        // GATT 客户端接口
    uint16_t conn_id,              // 连接 ID
    uint16_t start_handle,         // 起始句柄（通常填由获取服务函数得到的start_handle）
    uint16_t end_handle,           // 结束句柄（通常填由获取服务函数得到的end_handle）
    esp_gattc_db_elem_t *db,       // 输出：数据库条目数组
    uint16_t *count                // 输入/输出：数组元素数
);
```

### 开启gatt

用于替代旧版 `esp_ble_gattc_open` / `esp_ble_gattc_aux_open`，可以统一兼容 **BLE 4.2 与 BLE 5.0** 功能

```c
esp_err_t esp_ble_gattc_enh_open(
    esp_gatt_if_t                     gattc_if,
    esp_ble_gatt_creat_conn_params_t *create_conn
);
```

```c
            esp_ble_gatt_creat_conn_params_t creat_conn_params = {0};
            //获取远程服务端的信息
            memcpy(&creat_conn_params.remote_bda, scan_rst.scan_rst.bda,ESP_BD_ADDR_LEN);
            creat_conn_params.remote_addr_type = scan_rst.scan_rst.ble_addr_type;
            creat_conn_params.own_addr_type = BLE_ADDR_TYPE_PUBLIC;
            creat_conn_params.is_direct = true;
            creat_conn_params.is_aux = false;
            creat_conn_params.phy_mask = 0x0;
            //建立连接
            esp_ble_gattc_enh_open(gl_profile_tab[PROFILE_APP_ID].gattc_if,
                                &creat_conn_params);
```

### 设置/获取属性的值

```c
//会触发ESP_GATTS_SET_ATTR_VAL_EVT事件
esp_err_t esp_ble_gatts_set_attr_value(uint16_t attr_handle, uint16_t length, const uint8_t *value);


esp_gatt_status_t esp_ble_gatts_get_attr_value(uint16_t attr_handle, uint16_t *length, const uint8_t **value);
```

# SMP安全配对

# 蓝牙HID控制

