# 蓝牙发展史

![image-20250713095728181](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507130957237.png)

# 蓝牙协议栈

[蓝牙学习一（简介）_蓝牙profile-CSDN博客](https://blog.csdn.net/qq_26226375/article/details/127906179?spm=1001.2014.3001.5501)

![image-20250713101544647](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507131015719.png)

上图为**Nordic的架构**

PHY：物理层，用来指定无线频段，调制解调方式，PHY层直接决定了蓝牙的功耗和灵敏度等射频特性

LL：链路层，LL层是整个协议的核心，负责接收或者发送数据，对于数据的解析则是GAP或者ATT来负责

HCI：可选择的，用来规范两者之间的通讯协议和通信命令等

GAP：通用访问规范文件，对LL层的有效数据包进行解析，目前主要用来进行**广播**，**扫描**和**发起连接**

L2CAP：逻辑链路控制和适配协议，对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理

SMP：加密管理协议，SMP用来管理BLE连接的加密和安全

ATT：属性协议，ATT层用来定义用户命令及命令操作的数据，BLE引入了attribute概念，用来描述一条一条的数据。Attrubute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层

GATT：通用属性配置文件，GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑。但互联互通就会出问题

> **ATT和GATT的关系就像车辆和交通规则一样**。ATT就是车辆，而GATT就是规范车辆该如何行驶的交通规则。只有GATT存在的时候，多个ATT见面才知道该如何形式，到底是拐弯让直行还是坐车道超车



## 蓝牙控制器

由硬件实现，包括BLE控制器，BR/EDR控制器和5.3版本删除的AMP控制器

![image-20250713101829867](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507131018913.png)

## 蓝牙主机

主机是由软件实现的

![image-20250713102156450](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507131021496.png)

## 专业术语

- GAP: 通用访问
- GATT/ATT: 通用属性
- SMP: 安全管理
- SDP: 服务发现
- L2CAP: 链路管理与适配
- HCI: 主机控制接口
- DM: 设备管理
- LM: 链路管理
- LC: 链路控制
- PHY: 物理层

## esp32的蓝牙

esp使用的是谷歌开发的bluedriod蓝牙协议栈

# 蓝牙GAP

[蓝牙低功耗（BLE）：GAP详解：设备发现、连接与安全配置-CSDN博客](https://blog.csdn.net/qq_26226375/article/details/128017160)

generic access profile **通用访问规范**

GAP层与应用层紧密相连，也就是蓝牙协议栈的栈顶，目前主要用来进行广播、扫描和发起连接。GAP保证了不同的设备可以互相发现对方并建立连接

GAP就好比一种语言，大家都说同一种语言才能相互听懂，相互知道说的是什么。否则就只能大眼瞪小眼

## GAP定义了四种角色

- 广播者：用于只通过广播发送数据的应用。只是广播信息让接收者发现自己，但是不可用被连接，比如苹果的iBeacon
- 观察者：只是进行扫描，监听广播的数据，不能建立连接，比如BLE Sniffer蓝牙协议分析仪
- 外围设备：广播数据，可以被连接，被连接后成为从机
- 中央设备：接收到广播的信息后，可以建立连接，在通信中作为主机，支持三个同时连接

## GAP提供如下功能

- 广播：设置和获取广播参数，启动和停止广播，有idle、start、advertising和stop四个状态
- 扫描：设置和获取扫描参数，启动和停止扫描，有idle、start、scaning和stop四个状态
- 连接：设置，更新参数，创建终止连接
- 配对：设置参数，启动配对
- 密钥管理：根据设备地址和地址类型查找密钥，保存/加载绑定设备信息的密钥，解析random address

## Beacon信标广播

- Beacon是一种用于营销和定位的短距离无线通信蓝牙设备，是蓝牙低功耗协议中的外围设备
- 信标本质是一种**蓝牙广播**标准，该标准不是蓝牙技术联盟所制定的标准，它被称为“虚拟标准”
- Eddston是谷歌公司制定的标准，可以广播四种帧格式，自定义唯一的信标ID（UID）、广播网址（URL）、广播自身数据（E表示加密）（TLM/ETLM）、加密的临时标识符（EID）

UID：最多有128位，实际上只用到了16位或者32位，是在官方注册的

UUID：通用唯一标识符，最多128位，实际上用了16或者32位，这一个ID里面有公司, 对象特征值类型, 属性类型声明, 属性特征描述符, 属性服务, 计量单位, 协助标识符, 标准开发组织, 服务规范ID

## BLE广播包格式

![image-20250715173448476](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151734542.png)

- 访问地址分为两种
  - 广播接入地址：固定值，0x8E89BED6，在广播，扫描，发起连接时使用
  - 数据接入地址：随机值，不同的连接有不同的值，在建立连接后的两个设备间使用
- Header
  - Header_1：广播的类型，发送地址类型和接收地址类型，给0表示公开，给1表示随机
  - Header_2：表示长度，为6-37字节，不包含3个字节的CRC检验位，最少6个字节是因为PDU里面有6个字节的自身地址，最后的有效载荷才是真正的广播数据
- AD结构：包含类型，长度和数据

![image-20250715173749148](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151737214.png)

## EddyStone数据包格式

[ESP32S3蓝牙学习系列---Beacon信标之Eddystone-CSDN博客](https://blog.csdn.net/yplwrt/article/details/129107710)

![image-20250715174930491](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151749552.png)

Type：0x01表示flag，值为0x06，则对应下图，普通发现模式和不支持BR/EDR（不支持传统蓝牙）

![image-20250715175023946](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151750983.png)

Type：0x03

![image-20250715175458275](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151754304.png)

UUID：0xAA,0xFE表示谷歌

Type：0x16

![image-20250715175743589](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151757623.png)

EddyStone的数据格式有四种UID，URL，TLM，EID

> - UID：这是由三个字段组成的主要Eddystone框架，即命名空间标识符（10byte），实例标识符（6byte）和功率校准（1byte）。他将有助于将字段直接配置到BLE信标中，实例标识符旨在唯一地表示一个信标，因为他们具有不同的实例ID，功率校准字段用于根据RSSI帮助计算移动设备和Eddystone信标之间的距离。
> - URL：该框架的主要目的是提供一种传输URL的方法，以便蓝牙低功耗扫描仪设备检测和发现它，然后BLE设备将连接收到并为用户显示正确的网页。BLE信标发送Eddystone-URL资源，智能手机等移动设备在检测到信标数据后立即在浏览器中自动打开网址。同时该框架提供类似于Eddystone-UID的功率校准功能。
>   - ![image-20250715180223549](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151802585.png)
> - TLM：Eddystone-TML 框架的主要是提供关于Eddystone的健康状况的完整报告。当前温度, 当前电池电量, 正常运行时间 (信标已通电的秒数), 和 PduCount (信标在最后一次供电后部署的广告数据包的数量).
> - EID：这是负责小工具安全和隐私的框架



## 示例

![image-20250715182509645](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151825704.png)

![](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507142203871.png)

![image-20250715180406758](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507151804816.png)

[GAP API - ESP32 - — ESP-IDF 编程指南 v5.4.2 文档](https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/api-reference/bluetooth/esp_gap_ble.html)

### Beacon扫描

```c
/*
 * SPDX-FileCopyrightText: 2021-2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Unlicense OR CC0-1.0
 */


/****************************************************************************
*
* This file is used for eddystone receiver.
*
****************************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <inttypes.h>

#include "esp_bt.h"
#include "nvs_flash.h"
#include "esp_log.h"
#include "esp_bt_defs.h"
#include "esp_bt_main.h"
#include "esp_gatt_defs.h"
#include "esp_gattc_api.h"
#include "esp_gap_ble_api.h"
#include "freertos/FreeRTOS.h"

#include "esp_eddystone_protocol.h"
#include "esp_eddystone_api.h"

static const char* DEMO_TAG = "EDDYSTONE_DEMO";

/* declare static functions */
static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t* param);
static void esp_eddystone_show_inform(const esp_eddystone_result_t* res);

//扫描的参数设置
static esp_ble_scan_params_t ble_scan_params = {
    .scan_type              = BLE_SCAN_TYPE_ACTIVE,  //扫描类型
    .own_addr_type          = BLE_ADDR_TYPE_PUBLIC,  //所有者的地址类型
    .scan_filter_policy     = BLE_SCAN_FILTER_ALLOW_ALL,
    .scan_interval          = 0x50,   //扫描间隔
    .scan_window            = 0x30,   //扫描的持续时间，小于扫描间隔
    .scan_duplicate         = BLE_SCAN_DUPLICATE_DISABLE  //是否过率重复包
};

static void esp_eddystone_show_inform(const esp_eddystone_result_t* res)
{
    switch(res->common.frame_type)
    {
        case EDDYSTONE_FRAME_TYPE_UID: {
            ESP_LOGI(DEMO_TAG, "Eddystone UID inform:");
            ESP_LOGI(DEMO_TAG, "Measured power(RSSI at 0m distance):%d dbm", res->inform.uid.ranging_data);
            ESP_LOGI(DEMO_TAG, "EDDYSTONE_DEMO: Namespace ID:0x");
            ESP_LOG_BUFFER_HEX(DEMO_TAG, res->inform.uid.namespace_id, 10);
            ESP_LOGI(DEMO_TAG, "EDDYSTONE_DEMO: Instance ID:0x");
            ESP_LOG_BUFFER_HEX(DEMO_TAG, res->inform.uid.instance_id, 6);
            break;
        }
        case EDDYSTONE_FRAME_TYPE_URL: {
            ESP_LOGI(DEMO_TAG, "Eddystone URL inform:");
            ESP_LOGI(DEMO_TAG, "Measured power(RSSI at 0m distance):%d dbm", res->inform.url.tx_power);
            ESP_LOGI(DEMO_TAG, "URL: %s", res->inform.url.url);
            break;
        }
        case EDDYSTONE_FRAME_TYPE_TLM: {
            ESP_LOGI(DEMO_TAG, "Eddystone TLM inform:");
            ESP_LOGI(DEMO_TAG, "version: %d", res->inform.tlm.version);
            ESP_LOGI(DEMO_TAG, "battery voltage: %d mV", res->inform.tlm.battery_voltage);
            ESP_LOGI(DEMO_TAG, "beacon temperature in degrees Celsius: %6.1f", res->inform.tlm.temperature);
            ESP_LOGI(DEMO_TAG, "adv pdu count since power-up: %" PRIu32, res->inform.tlm.adv_count);
            ESP_LOGI(DEMO_TAG, "time since power-up: %" PRIu32 " s", (res->inform.tlm.time)/10);
            break;
        }
        default:
            break;
    }
}

static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t* param)
{
    esp_err_t err;

    switch(event)
    {
            //扫描参数设置完成事件
        case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: {
            uint32_t duration = 0;//保持扫描的时间，单位为秒
            esp_ble_gap_start_scanning(duration);
            break;
        }
            //扫描开始完成事件
        case ESP_GAP_BLE_SCAN_START_COMPLETE_EVT: {
            if((err = param->scan_start_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
                ESP_LOGE(DEMO_TAG,"Scan start failed: %s", esp_err_to_name(err));
            }
            else {
                ESP_LOGI(DEMO_TAG,"Start scanning...");
            }
            break;
        }
            //扫描结果事件
        case ESP_GAP_BLE_SCAN_RESULT_EVT: {
            esp_ble_gap_cb_param_t* scan_result = (esp_ble_gap_cb_param_t*)param;
            switch(scan_result->scan_rst.search_evt)
            {
                    //搜索结果事件
                case ESP_GAP_SEARCH_INQ_RES_EVT: {
                    esp_eddystone_result_t eddystone_res;
                    memset(&eddystone_res, 0, sizeof(eddystone_res));
                    //解析广播包是否为EddyStone包
                    esp_err_t ret = esp_eddystone_decode(scan_result->scan_rst.ble_adv, scan_result->scan_rst.adv_data_len, &eddystone_res);
                    if (ret) {
                        // error:The received data is not an eddystone frame packet or a correct eddystone frame packet.
                        // just return
                        return;
                    } else {
                        // The received adv data is a correct eddystone frame packet.
                        // Here, we get the eddystone information in eddystone_res, we can use the data in res to do other things.
                        // For example, just print them:
                        ESP_LOGI(DEMO_TAG, "--------Eddystone Found----------");
                        ESP_LOG_BUFFER_HEX("EDDYSTONE_DEMO: Device address:", scan_result->scan_rst.bda, ESP_BD_ADDR_LEN);
                        ESP_LOGI(DEMO_TAG, "RSSI of packet:%d dbm", scan_result->scan_rst.rssi);
                        esp_eddystone_show_inform(&eddystone_res);
                    }
                    break;
                }
                default:
                    break;
            }
            break;
        }
            //扫描停止完成事件
        case ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT:{
            if((err = param->scan_stop_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
                ESP_LOGE(DEMO_TAG,"Scan stop failed: %s", esp_err_to_name(err));
            }
            else {
                ESP_LOGI(DEMO_TAG,"Stop scan successfully");
            }
            break;
        }
        default:
            break;
    }
}

void esp_eddystone_appRegister(void)
{
    esp_err_t status;

    ESP_LOGI(DEMO_TAG,"Register callback");

    /*<! register the scan callback function to the gap module */
    if((status = esp_ble_gap_register_callback(esp_gap_cb)) != ESP_OK) {
        ESP_LOGE(DEMO_TAG,"gap register error: %s", esp_err_to_name(status));
        return;
    }
}

void esp_eddystone_init(void)
{
    esp_bluedroid_init();
    esp_bluedroid_enable();
    esp_eddystone_appRegister();
}

void app_main(void)
{
    ESP_ERROR_CHECK(nvs_flash_init());

    //释放经典蓝牙控制器
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    //初始化并开启BLE蓝牙控制器
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    esp_bt_controller_init(&bt_cfg);
    esp_bt_controller_enable(ESP_BT_MODE_BLE);

    //eddystone初始化
    esp_eddystone_init();

    /*设置扫描参数 */
    esp_ble_gap_set_scan_params(&ble_scan_params);
}
```

### 广播

```c
//UUID
static uint8_t adv_service_uuid128[16] = {
    /* LSB <--------------------------------------------------------------------------------> MSB */
    //first uuid, 16bit, [12],[13] is the value
    0xfb, 0x34, 0x9b, 0x5f, 0x80, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0xAA, 0xFE, 0x00, 0x00,

};

//广播数据EddyStones帧参数
/* 广播/扫描响应里要携带的「数据内容」 */
static esp_ble_adv_data_t adv_data = {
    .set_scan_rsp        = false,          // 这些数据放在「普通广播包」里，而不是扫描响应包
    .include_name        = true,           // 广播包里要包含「设备完整名称」
    .include_txpower     = true,           // 广播包里要包含「发射功率」字段（方便客户端估算距离）
    .min_interval        = 0x0006,         // 建议中央设备在建立连接后使用的最小连接间隔
                                           // 0x0006 * 1.25 ms = 7.5 ms
    .max_interval        = 0x000C,         // 建议最大连接间隔
                                           // 0x000C * 1.25 ms = 15 ms
    .appearance          = 0x00,           // 外观类型（0x00 = 未知/通用）
    .manufacturer_len    = 0,              // 厂商自定义数据长度；0 表示不携带
    .p_manufacturer_data = NULL,           // 指向厂商数据的指针
    .service_data_len    = 0,              // Service Data 长度；0 表示不携带
    .p_service_data      = NULL,           // 指向 Service Data 的指针
    .service_uuid_len    = 16,             // 128-bit Service UUID 长度（字节数）
    .p_service_uuid      = adv_service_uuid128, // 指向 128-bit Service UUID 数组
    .flag                = (ESP_BLE_ADV_FLAG_GEN_DISC |  // 标志位：通用可发现模式
                            ESP_BLE_ADV_FLAG_BREDR_NOT_SPT), // 同时声明「不支持经典蓝牙（BR/EDR）」
};

// 控制「广播行为/时序」的参数 广播包Advertising Packet参数
static esp_ble_adv_params_t adv_params = {
    .adv_int_min        = 0x20,            // 最小广播间隔
                                           // 0x20 * 0.625 ms = 20 ms
    .adv_int_max        = 0x40,            // 最大广播间隔
                                           // 0x40 * 0.625 ms = 40 ms
    .adv_type           = ADV_TYPE_IND,    // 广播类型：通用可连接、可扫描的「ADV_IND」
    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC, // 使用芯片的公共地址（Public Address）
    .channel_map        = ADV_CHNL_ALL,    // 在 37/38/39 三个广播信道全部发送
    .adv_filter_policy  = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, // 不启用白名单，任何设备都可扫描/连接
    
    //下面两个只在 定向广播（Directed Advertising）时才需要填写，普通广播可忽略
    //如果你想让外设立即被某个已配对手机连接，而不想让其它手机扫描到，就把广播类型设成 ADV_TYPE_DIRECT_IND，然后填这两字段
    //.peer_addr            = //目标设备的 6 字节蓝牙地址（BD_ADDR）
    //.peer_addr_type       = //上述地址的类型
};


eddystone_uid_t uid;

//这里的话，发送URL，TLM，EID都有对应的函数，返回值是服务数据的长度，然后配合上面的Beacon扫描就可以验证是否发送成功
int len = Eddystone_Set_UID(&uid, 10, (uint8_t *)"hello", (uint8_t *)"12345");
if(len == -1){
    ESP_LOGE("main", "get eddystone error");
    return;
}
adv_data.service_data_len = len;
adv_data.p_service_data = (uint8_t *)&uid;

esp_ble_gap_config_adv_data(&adv_data);
esp_ble_gap_start_advertising(&adv_params); //这一个函数最好放在回调函数里面，就是在如上面的函数esp_gap_cb里面，加一个广播参数设置完成事件

```

# 蓝牙GATT/ATT

- ATT它是处于L2CAP协议层与GATT之间的一层属性操作协议
- ATT基本属性：属性句柄（属性表下标索引），属性类型（由UUID定义），属性值以及访问权限
- ATT就相当于设备的数据库

- GATT通用属性配置文件，GATT层是传输真正数据的层，包括了一个数据传输和存储架构以及其基本操作
- GATT用来规范attribute（ATT）中的数据内容
- GATT定义了两种角色：服务端和客户端（server和client），一个设备可以同时成为客户端和服务端
- GATT可以进行交换配置, 发现对方设备服务和特性, 读写特征值, 特征值的通知和指示

![image-20250716175512855](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161755966.png)

## SPP串口透传

![image-20250716175555720](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161755828.png)

![](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161808340.png)

- 在蓝牙设备扫描结果查询中，**SDP（Service Discovery Protocol，服务发现协议）** 的核心作用是**帮助客户端设备发现并识别远程设备所支持的服务及其特性**，从而决定是否建立连接
- SDP 允许客户端在扫描到蓝牙设备后，进一步查询该设备支持哪些服务（如音频传输、文件传输、打印服务等）。每个服务以“服务记录（Service Record）”的形式存在，包含服务类型、UUID、名称、所需协议等属性

![image-20250716181622041](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161816199.png)

![image-20250716182305586](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161823721.png)

![image-20250716182346005](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161823121.png)

## 服务特征属性表

### UUID

![image-20250716182530303](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161825400.png)

### 服务属性表

![image-20250716182843785](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507161828907.png)

### 属性表

```c

/**
 * @brief attribute type added to the GATT server database
 */
typedef struct
{
    esp_attr_control_t      attr_control;                   //是否使用自动回复
    esp_attr_desc_t         att_desc;                       /*!< The attribute type */
} esp_gatts_attr_db_t;


typedef struct
{
    /**
     * @brief Controls who handles the response to Read/Write operations.
     *
     * - If set to @c ESP_GATT_RSP_BY_APP, the application is responsible for
     *   generating the response.
     * - If set to @c ESP_GATT_AUTO_RSP, the GATT stack will automatically generate
     *   the response.
     */
    uint8_t auto_rsp;
} esp_attr_control_t;

typedef struct
{
    uint16_t uuid_length;              //uuid长度
    uint8_t  *uuid_p;                  //uuid数据指针
    uint16_t perm;                     //客户端对声明的权限 
    uint16_t max_length;               //当前属性最大长度
    uint16_t length;                   //当前属性的实际长度
    uint8_t  *value;                   //属性数据指针
} esp_attr_desc_t;


//BLE GATT Server 中定义一个完整的 GATT 数据库表（attribute database），也就是告诉蓝牙协议栈：
//“我要提供哪些服务（Service）、特征（Characteristic）、描述符（Descriptor），以及它们的权限、初始值、UUID 等信息。”
static const esp_gatts_attr_db_t spp_gatt_db[SPP_IDX_NB] =
{
    //是否自动回复，uuid长度，uuid指针，客户端对声明的权限，最大长度，当前长度，数据指针

    //SPP -  Service Declaration 0x2800 主要服务
    [SPP_IDX_SVC]                      	=
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ,
    sizeof(spp_service_uuid), sizeof(spp_service_uuid), (uint8_t *)&spp_service_uuid}},

    //SPP -  data receive characteristic Declaration 0x2803 定义一个接收数据的特征（客户端 → 服务端esp）。
    //是特征的声明（告诉客户端“我有个可读写特征”）
    [SPP_IDX_SPP_DATA_RECV_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}},

    //SPP -  data receive characteristic Value 
    //是特征的实际值（存储接收到的数据）
    [SPP_IDX_SPP_DATA_RECV_VAL]             	=
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_data_receive_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    SPP_DATA_MAX_LEN,sizeof(spp_data_receive_val), (uint8_t *)spp_data_receive_val}},

    //SPP -  data notify characteristic Declaration 声明特征值
    //定义一个发送数据的特征（服务端esp → 客户端），通过通知（Notify）方式
    //声明支持通知
    [SPP_IDX_SPP_DATA_NOTIFY_CHAR]  =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_notify}},

    //SPP -  data notify characteristic Value
    //实际发送给客户端的数据
    [SPP_IDX_SPP_DATA_NTY_VAL]   =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_data_notify_uuid, ESP_GATT_PERM_READ,
    SPP_DATA_MAX_LEN, sizeof(spp_data_notify_val), (uint8_t *)spp_data_notify_val}},

    //SPP -  data notify characteristic - Client Characteristic Configuration Descriptor
    //客户端配置描述符（CCCD），用于启用/禁用通知（客户端写 0x0001 开启通知）
    [SPP_IDX_SPP_DATA_NTF_CFG]         =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(uint16_t),sizeof(spp_data_notify_ccc), (uint8_t *)spp_data_notify_ccc}},

    //SPP -  command characteristic Declaration
    //定义一个命令特征（客户端 → 服务端ESP32），比如发送控制指令
    //这里是声明
    [SPP_IDX_SPP_COMMAND_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}},

    //SPP -  command characteristic Value
    //这里是接收到客户端的数据
    [SPP_IDX_SPP_COMMAND_VAL]                 =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_command_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    SPP_CMD_MAX_LEN,sizeof(spp_command_val), (uint8_t *)spp_command_val}},

    //SPP -  status characteristic Declaration
    //定义一个状态特征（服务端ESP32 → 客户端），通过通知上报设备状态（比如“已连接”“错误码”）
    //这里是声明有这样一的状态特征
    [SPP_IDX_SPP_STATUS_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_notify}},

    //SPP -  status characteristic Value
    //这里是存放状态数据的地方
    [SPP_IDX_SPP_STATUS_VAL]                 =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_status_uuid, ESP_GATT_PERM_READ,
    SPP_STATUS_MAX_LEN,sizeof(spp_status_val), (uint8_t *)spp_status_val}},

    //SPP -  status characteristic - Client Characteristic Configuration Descriptor
    //客户端特征配置描述符 CCCD，让客户端 开关通知
    //客户端写 0x0001 → 打开通知，ESP32 以后可主动发 notify（即状态数据）；
    //客户端写 0x0000 → 关闭通知。
    [SPP_IDX_SPP_STATUS_CFG]         =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(uint16_t),sizeof(spp_status_ccc), (uint8_t *)spp_status_ccc}},

    //支持心跳特征
#ifdef SUPPORT_HEARTBEAT
    //SPP -  Heart beat characteristic Declaration
    //特征声明，支持 读、写、通知（Read | Write | Notify） 三种操作
    [SPP_IDX_SPP_HEARTBEAT_CHAR]  =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ,
    CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write_notify}},

    //SPP -  Heart beat characteristic Value
    //特征值，一个双向数据槽，客户端可以随时写一段心跳数据表示我还或者，也可以读取当前心跳值
    [SPP_IDX_SPP_HEARTBEAT_VAL]   =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_heart_beat_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(spp_heart_beat_val), sizeof(spp_heart_beat_val), (uint8_t *)spp_heart_beat_val}},

    //SPP -  Heart beat characteristic - Client Characteristic Configuration Descriptor
    //客户端特征配置描述符 CCCD，让客户端 开关通知
    // 写 0x0001 → 打开 notify，ESP32 可定时把心跳值推给手机
    //写 0x0000 → 关闭 notify。
    [SPP_IDX_SPP_HEARTBEAT_CFG]         =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
    sizeof(uint16_t),sizeof(spp_data_notify_ccc), (uint8_t *)spp_heart_beat_ccc}},
#endif
};


//创建属性表，在gatts_profile_event_handler的ESP_GATTS_REG_EVT事件里面进行创建
esp_ble_gatts_create_attr_tab(spp_gatt_db, gatts_if, SPP_IDX_NB, SPP_SVC_INST_ID);
//创建完成后会进入ESP_GATTS_CREAT_ATTR_TAB_EVT事件，在gatts协议栈回调中
```



## 服务器示例

### 初始化

```c
void app_main(void)
{
    esp_err_t ret;
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    // 初始化flash
    ret = nvs_flash_init();
    //释放经典蓝牙控制器内存
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    //初始化蓝牙控制器
    ret = esp_bt_controller_init(&bt_cfg);
    //使能低功耗蓝牙控制器
    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    //初始化bluedroid蓝牙协议栈
    ret = esp_bluedroid_init();
    //开启bluedroid蓝牙协议栈
    ret = esp_bluedroid_enable();
    //注册回调，GAP事件回调，GATTS事件回调，GATTS_APP
    esp_ble_gatts_register_callback(gatts_event_handler);
    esp_ble_gap_register_callback(gap_event_handler);
    esp_ble_gatts_app_register(ESP_SPP_APP_ID);
    //创建任务
    spp_task_init();
    //设置最大传输量
    esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500);

    return;
}
```

### gap回调

```c
static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{
    esp_err_t err;
    ESP_LOGI(GATTS_TABLE_TAG, "GAP_EVT, event %d", event);

    switch (event) {
        //原始广播数据设置完成事件
    case ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT:
        //开启广播
        esp_ble_gap_start_advertising(&spp_adv_params);
        break;
        //开启广播完成事件
    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        //advertising start complete event to indicate advertising start successfully or failed
        if((err = param->adv_start_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTS_TABLE_TAG, "Advertising start failed: %s", esp_err_to_name(err));
        }
        break;
    default:
        break;
    }
}
```

### gatts协议栈回调

```c
static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    esp_ble_gatts_cb_param_t *p_data = (esp_ble_gatts_cb_param_t *) param;
    uint8_t res = 0xff;

    ESP_LOGI(GATTS_TABLE_TAG, "event = %x",event);
    switch (event) {
            //GATT Serve注册事件，由esp_ble_gatts_app_register触发
    	case ESP_GATTS_REG_EVT:
    	    ESP_LOGI(GATTS_TABLE_TAG, "%s %d", __func__, __LINE__);
        	esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME);

        	ESP_LOGI(GATTS_TABLE_TAG, "%s %d", __func__, __LINE__);
            //设置原始广播数据
        	esp_ble_gap_config_adv_data_raw((uint8_t *)spp_adv_data, sizeof(spp_adv_data));

            //创建属性表
        	ESP_LOGI(GATTS_TABLE_TAG, "%s %d", __func__, __LINE__);
        	esp_ble_gatts_create_attr_tab(spp_gatt_db, gatts_if, SPP_IDX_NB, SPP_SVC_INST_ID);
       	break;
            
        //GATT读事件，当远端 BLE 客户端（Client）想读取设备上的某个特征值（Characteristic）时触发。
       //esp_ble_gattc_read_char() 或 esp_ble_gattc_read_char_descr()触发
    	case ESP_GATTS_READ_EVT:
            res = find_char_and_desr_index(p_data->read.handle);//客户端想读取的 attribute handle
            //客户端想要读取 STATUS 特征值
            if(res == SPP_IDX_SPP_STATUS_VAL){
                //TODO:client read the status characteristic
                //可以调用esp_ble_gatts_send_response来回应
                //如果不调用 esp_ble_gatts_send_response()，客户端会 读超时（报错 ESP_GATT_READ_NOT_PERMIT 或 ESP_GATT_ERROR）
            }
       	 break;
         //GATT写入事件，用来接收并处理 BLE 客户端（Client）写特征值 的行为 esp_ble_gattc_write_char_descr后触发，也可以由客户端的ESP_GATTC_WRITE_CHAR_EVT事件触发（如果向服务端发送了写请求的话）
    	case ESP_GATTS_WRITE_EVT: {
    	    res = find_char_and_desr_index(p_data->write.handle);
            //判断是直接写入还是准备写入缓存 false是直接写入
            if(p_data->write.is_prep == false){
                ESP_LOGI(GATTS_TABLE_TAG, "ESP_GATTS_WRITE_EVT : handle = %d", res);
                //自定义“命令”特征值，客户端下发 控制命令 给服务端
                if(res == SPP_IDX_SPP_COMMAND_VAL){
                    uint8_t * spp_cmd_buff = NULL;
                    spp_cmd_buff = (uint8_t *)malloc((spp_mtu_size - 3) * sizeof(uint8_t));
                    if(spp_cmd_buff == NULL){
                        ESP_LOGE(GATTS_TABLE_TAG, "%s malloc failed", __func__);
                        break;
                    }
                    memset(spp_cmd_buff,0x0,(spp_mtu_size - 3));
                    memcpy(spp_cmd_buff,p_data->write.value,p_data->write.len);
                    xQueueSend(cmd_cmd_queue,&spp_cmd_buff,10/portTICK_PERIOD_MS);
                }
                //“数据”特征的 CCCD 描述符，客户端 打开/关闭数据通知
                else if(res == SPP_IDX_SPP_DATA_NTF_CFG){
                    if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x01)&&(p_data->write.value[1] == 0x00)){
                        enable_data_ntf = true;
                    }else if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x00)&&(p_data->write.value[1] == 0x00)){
                        enable_data_ntf = false;
                    }
                }
                //“心跳”特征的 CCCD 描述符，客户端 打开/关闭心跳通知
#ifdef SUPPORT_HEARTBEAT
                else if(res == SPP_IDX_SPP_HEARTBEAT_CFG){
                    if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x01)&&(p_data->write.value[1] == 0x00)){
                        enable_heart_ntf = true;
                    }else if((p_data->write.len == 2)&&(p_data->write.value[0] == 0x00)&&(p_data->write.value[1] == 0x00)){
                        enable_heart_ntf = false;
                    }
                }
                //心跳值特征，客户端发来 心跳包数据
                else if(res == SPP_IDX_SPP_HEARTBEAT_VAL){
                    if((p_data->write.len == sizeof(heartbeat_s))&&(memcmp(heartbeat_s,p_data->write.value,sizeof(heartbeat_s)) == 0)){
                        heartbeat_count_num = 0;
                    }
                }
#endif
                //	数据接收特征，客户端发来 普通业务/串口数据
                else if(res == SPP_IDX_SPP_DATA_RECV_VAL){
#ifdef SPP_DEBUG_MODE
                    ESP_LOG_BUFFER_CHAR(GATTS_TABLE_TAG,(char *)(p_data->write.value),p_data->write.len);
#else
                    uart_write_bytes(UART_NUM_0, (char *)(p_data->write.value), p_data->write.len);
#endif
                }else{
                    //TODO:
                }
            }
            //准备写入缓存
            else if((p_data->write.is_prep == true)&&(res == SPP_IDX_SPP_DATA_RECV_VAL)){
                ESP_LOGI(GATTS_TABLE_TAG, "ESP_GATTS_PREP_WRITE_EVT : handle = %d", res);
                //写入缓存
                store_wr_buffer(p_data);
            }
      	 	break;
    	}
        //GATT执行写入事件
    	case ESP_GATTS_EXEC_WRITE_EVT:{
    	    ESP_LOGI(GATTS_TABLE_TAG, "ESP_GATTS_EXEC_WRITE_EVT");
            //判断是不是要写入
    	    if(p_data->exec_write.exec_write_flag){
    	        print_write_buffer();
    	        free_write_buffer();
    	    }
    	    break;
    	}
        
        //记录最大传输单元
    	case ESP_GATTS_MTU_EVT:
    	    spp_mtu_size = p_data->mtu.mtu;
    	    break;
    	case ESP_GATTS_CONF_EVT:
    	    break;
    	case ESP_GATTS_UNREG_EVT:
        	break;
    	case ESP_GATTS_DELETE_EVT:
        	break;
    	case ESP_GATTS_START_EVT:
        	break;
    	case ESP_GATTS_STOP_EVT:
        	break;
            
        //连接事件
    	case ESP_GATTS_CONNECT_EVT:
    	    spp_conn_id = p_data->connect.conn_id;
    	    spp_gatts_if = gatts_if;
    	    is_connected = true;
            //拷贝对方蓝牙地址
    	    memcpy(&spp_remote_bda,&p_data->connect.remote_bda,sizeof(esp_bd_addr_t));
            
            //发送心跳队列
#ifdef SUPPORT_HEARTBEAT
    	    uint16_t cmd = 0;
            xQueueSend(cmd_heartbeat_queue,&cmd,10/portTICK_PERIOD_MS);
#endif
        	break;
            
            //GATTS断开连接事件，当远端 BLE 客户端主动断开连接 或 连接异常丢失 时触发
    	case ESP_GATTS_DISCONNECT_EVT:
            spp_mtu_size = 23;
    	    is_connected = false;
    	    enable_data_ntf = false;
#ifdef SUPPORT_HEARTBEAT
    	    enable_heart_ntf = false;
    	    heartbeat_count_num = 0;
#endif
            //开始广播
    	    esp_ble_gap_start_advertising(&spp_adv_params);
    	    break;
    	case ESP_GATTS_OPEN_EVT:
    	    break;
    	case ESP_GATTS_CANCEL_OPEN_EVT:
    	    break;
    	case ESP_GATTS_CLOSE_EVT:
    	    break;
    	case ESP_GATTS_LISTEN_EVT:
    	    break;
    	case ESP_GATTS_CONGEST_EVT:
    	    break;
        
        //创建属性表完成事件
    	case ESP_GATTS_CREAT_ATTR_TAB_EVT:{
    	    ESP_LOGI(GATTS_TABLE_TAG, "The number handle =%x",param->add_attr_tab.num_handle);
    	    if (param->add_attr_tab.status != ESP_GATT_OK){
    	        ESP_LOGE(GATTS_TABLE_TAG, "Create attribute table failed, error code=0x%x", param->add_attr_tab.status);
    	    }
    	    else if (param->add_attr_tab.num_handle != SPP_IDX_NB){
    	        ESP_LOGE(GATTS_TABLE_TAG, "Create attribute table abnormally, num_handle (%d) doesn't equal to HRS_IDX_NB(%d)", param->add_attr_tab.num_handle, SPP_IDX_NB);
    	    }
    	    else {
                //esp_ble_gatts_create_attr_tab() 或 esp_ble_gatts_start_service() 被调用后，
                // ESP-IDF 会把上面的模板（即我们自己写的GATT 数据库表）实例化成一张真正的“属性表”：
                // 每个条目得到一个16-bit 句柄 (handle) —— 从 0x0001 开始连续编号；
                // 条目顺序与模板一致：先 Service 声明 → Char 声明 → Char Value → CCCD …
                // 运行时保存在 RAM 中，客户端以后就用这些 handle 去访问 。
                // 把协议栈生成的 GATT 属性句柄保存下来，后续读写通知都要靠这些句柄来定位。
    	        memcpy(spp_handle_table, param->add_attr_tab.handles, sizeof(spp_handle_table));
                //开始GATTS服务
    	        esp_ble_gatts_start_service(spp_handle_table[SPP_IDX_SVC]);
    	    }
    	    break;
    	}
    	default:
    	    break;
    }
}
```

### gatts回调

```c
static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    ESP_LOGI(GATTS_TABLE_TAG, "EVT %d, gatts if %d", event, gatts_if);

    /* If event is register event, store the gatts_if for each profile */
    if (event == ESP_GATTS_REG_EVT) {
        if (param->reg.status == ESP_GATT_OK) {
            spp_profile_tab[SPP_PROFILE_APP_IDX].gatts_if = gatts_if;
        } else {
            ESP_LOGI(GATTS_TABLE_TAG, "Reg app failed, app_id %04x, status %d",param->reg.app_id, param->reg.status);
            return;
        }
    }

    do {
        int idx;
        for (idx = 0; idx < SPP_PROFILE_NUM; idx++) {
            if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
                    gatts_if == spp_profile_tab[idx].gatts_if) {
                if (spp_profile_tab[idx].gatts_cb) {
                    spp_profile_tab[idx].gatts_cb(event, gatts_if, param);
                }
            }
        }
    } while (0);
}

```

## 客户端示例

### 初始化

```c
void ble_client_appRegister(void)
{
    esp_err_t status;
    char err_msg[20];

    ESP_LOGI(GATTC_TAG, "register callback");

    //注册gap，gatt回调，gatt应用
    //register the scan callback function to the gap module
    if ((status = esp_ble_gap_register_callback(esp_gap_cb)) != ESP_OK) {
        ESP_LOGE(GATTC_TAG, "gap register error: %s", esp_err_to_name_r(status, err_msg, sizeof(err_msg)));
        return;
    }
    //register the callback function to the gattc module
    if ((status = esp_ble_gattc_register_callback(esp_gattc_cb)) != ESP_OK) {
        ESP_LOGE(GATTC_TAG, "gattc register error: %s", esp_err_to_name_r(status, err_msg, sizeof(err_msg)));
        return;
    }
    esp_ble_gattc_app_register(PROFILE_APP_ID);

    //配置最大传输单元
    esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(200);
    if (local_mtu_ret){
        ESP_LOGE(GATTC_TAG, "set local  MTU failed: %s", esp_err_to_name_r(local_mtu_ret, err_msg, sizeof(err_msg)));
    }

    //创建任务，队列
    cmd_reg_queue = xQueueCreate(10, sizeof(uint32_t));
    xTaskCreate(spp_client_reg_task, "spp_client_reg_task", 2048, NULL, 10, NULL);

#ifdef SUPPORT_HEARTBEAT
    cmd_heartbeat_queue = xQueueCreate(10, sizeof(uint32_t));
    xTaskCreate(spp_heart_beat_task, "spp_heart_beat_task", 2048, NULL, 10, NULL);
#endif
}


void app_main(void)
{
    esp_err_t ret;
	nvs_flash_init();
    
    //释放经典蓝牙控制器内存
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    
    //配置，初始化，启动低功耗蓝牙控制器
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&bt_cfg);
    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    
    //初始,使能BlueDroid
    ret = esp_bluedroid_init();
    ret = esp_bluedroid_enable();


    //注册客户端APP
    ble_client_appRegister();
    spp_uart_init();
}

```

### gap回调

```c
static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{
    uint8_t *adv_name = NULL;
    uint8_t adv_name_len = 0;
    esp_err_t err;

    switch(event){
        
    //设置扫描参数完成事件
    case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: {
        if((err = param->scan_param_cmpl.status) != ESP_BT_STATUS_SUCCESS){
            ESP_LOGE(GATTC_TAG, "Scan param set failed: %s", esp_err_to_name(err));
            break;
        }
        //the unit of the duration is second
        uint32_t duration = 0xFFFF;
        ESP_LOGI(GATTC_TAG, "Enable Ble Scan:during time %04" PRIx32 " minutes.",duration);
        //开始扫描
        esp_ble_gap_start_scanning(duration);
        break;
    }
    //开始扫描完成事件
    case ESP_GAP_BLE_SCAN_START_COMPLETE_EVT:
        //scan start complete event to indicate scan start successfully or failed
        if ((err = param->scan_start_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTC_TAG, "Scan start failed: %s", esp_err_to_name(err));
            break;
        }
        ESP_LOGI(GATTC_TAG, "Scan start successfully");
        break;
    //停止扫描完成事件
    case ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT:
        if ((err = param->scan_stop_cmpl.status) != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTC_TAG, "Scan stop failed: %s", esp_err_to_name(err));
            break;
        }
        ESP_LOGI(GATTC_TAG, "Scan stop successfully");
        //如果还没有连接
        if (is_connect == false) {
            ESP_LOGI(GATTC_TAG, "Connect to the remote device.");
            esp_ble_gatt_creat_conn_params_t creat_conn_params = {0};
            //把最后一次扫描结果里的设备地址作为连接目标
            memcpy(&creat_conn_params.remote_bda, scan_rst.scan_rst.bda,ESP_BD_ADDR_LEN);
            creat_conn_params.remote_addr_type = scan_rst.scan_rst.ble_addr_type;
            creat_conn_params.own_addr_type = BLE_ADDR_TYPE_PUBLIC;
            creat_conn_params.is_direct = true;
            creat_conn_params.is_aux = false;
            creat_conn_params.phy_mask = 0x0;
            //建立连接
            esp_ble_gattc_enh_open(gl_profile_tab[PROFILE_APP_ID].gattc_if,
                                &creat_conn_params);
        }
        break;
    //扫描结果事件，只要收到任何广播包/扫描响应就会触发
    case ESP_GAP_BLE_SCAN_RESULT_EVT: {
        esp_ble_gap_cb_param_t *scan_result = (esp_ble_gap_cb_param_t *)param;
        switch (scan_result->scan_rst.search_evt) {

        //子事件：每发现一个新设备就会触发
        case ESP_GAP_SEARCH_INQ_RES_EVT:
                //打印设备地址和广播长度
            ESP_LOG_BUFFER_HEX(GATTC_TAG, scan_result->scan_rst.bda, 6);
            ESP_LOGI(GATTC_TAG, "Searched Adv Data Len %d, Scan Response Len %d", scan_result->scan_rst.adv_data_len, scan_result->scan_rst.scan_rsp_len);
           
            //获取远程服务端的名字和长度
            adv_name = esp_ble_resolve_adv_data_by_type(scan_result->scan_rst.ble_adv,
                                                        scan_result->scan_rst.adv_data_len + scan_result->scan_rst.scan_rsp_len,
                                                        ESP_BLE_AD_TYPE_NAME_CMPL,
                                                        &adv_name_len);
            ESP_LOGI(GATTC_TAG, "Searched Device Name Len %d", adv_name_len);
            ESP_LOG_BUFFER_CHAR(GATTC_TAG, adv_name, adv_name_len);
            ESP_LOGI(GATTC_TAG, " ");
            //对比
            if (adv_name != NULL) {
                if ( strncmp((char *)adv_name, device_name, adv_name_len) == 0) {
                    memcpy(&(scan_rst), scan_result, sizeof(esp_ble_gap_cb_param_t));
                    esp_ble_gap_stop_scanning();//停止扫描
                }
            }
            break;
        case ESP_GAP_SEARCH_INQ_CMPL_EVT:
            break;
        default:
            break;
        }
        break;
    }
    //停止广播完成事件
    case ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:
        if ((err = param->adv_stop_cmpl.status) != ESP_BT_STATUS_SUCCESS){
            ESP_LOGE(GATTC_TAG, "Adv stop failed: %s", esp_err_to_name(err));
        }else {
            ESP_LOGI(GATTC_TAG, "Stop adv successfully");
        }
        break;
    default:
        break;
    }
}

```

### gattc协议栈回调

```c
static void gattc_profile_event_handler(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param)
{
    esp_ble_gattc_cb_param_t *p_data = (esp_ble_gattc_cb_param_t *)param;

    switch (event) {
        //注册 GATT 客户端成功后，开始扫描
    case ESP_GATTC_REG_EVT:
        ESP_LOGI(GATTC_TAG, "REG EVT, set scan params");
        esp_ble_gap_set_scan_params(&ble_scan_params);
        break;
        //连接成功事件
    case ESP_GATTC_CONNECT_EVT:
        ESP_LOGI(GATTC_TAG, "ESP_GATTC_CONNECT_EVT: conn_id=%d, gatt_if = %d", spp_conn_id, gattc_if);
        ESP_LOGI(GATTC_TAG, "REMOTE BDA:");
        ESP_LOG_BUFFER_HEX(GATTC_TAG, gl_profile_tab[PROFILE_APP_ID].remote_bda, sizeof(esp_bd_addr_t));
        
        //记录
        spp_gattc_if = gattc_if;
        is_connect = true;
        spp_conn_id = p_data->connect.conn_id;
        //记录设备地址
        memcpy(gl_profile_tab[PROFILE_APP_ID].remote_bda, p_data->connect.remote_bda, sizeof(esp_bd_addr_t));
     	//对服务进行搜索, 进入ESP_GATTC_SEARCH_RES_EVT
        esp_ble_gattc_search_service(spp_gattc_if, spp_conn_id, &spp_service_uuid);
        break;
        //断开连接事件
    case ESP_GATTC_DISCONNECT_EVT:
        ESP_LOGI(GATTC_TAG, "disconnect");
        //释放资源，重新开始扫描
        free_gattc_srv_db();
        esp_ble_gap_start_scanning(SCAN_ALL_THE_TIME);
        break;
        
    //每找到一个服务触发一次
    case ESP_GATTC_SEARCH_RES_EVT:
        ESP_LOGI(GATTC_TAG, "ESP_GATTC_SEARCH_RES_EVT: start_handle = %d, end_handle = %d, UUID:0x%04x",p_data->search_res.start_handle,p_data->search_res.end_handle,p_data->search_res.srvc_id.uuid.uuid.uuid16);
        //记录服务端的Handle数据
        spp_srv_start_handle = p_data->search_res.start_handle;
        spp_srv_end_handle = p_data->search_res.end_handle;
        break;
    
    //全部搜索完成触发一次
    case ESP_GATTC_SEARCH_CMPL_EVT:
        ESP_LOGI(GATTC_TAG, "SEARCH_CMPL: conn_id = %x, status %d", spp_conn_id, p_data->search_cmpl.status);
        //发送最大传输单元，之后进入ESP_GATTC_CFG_MTU_EVT事件
        esp_ble_gattc_send_mtu_req(gattc_if, spp_conn_id);
        break;
            
        //注册通知事件，esp_ble_gattc_register_for_notify()后触发
    case ESP_GATTC_REG_FOR_NOTIFY_EVT: {
        ESP_LOGI(GATTC_TAG,"Index = %d,status = %d,handle = %d",cmd, p_data->reg_for_notify.status, p_data->reg_for_notify.handle);
        if(p_data->reg_for_notify.status != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG, "ESP_GATTC_REG_FOR_NOTIFY_EVT, status = %d", p_data->reg_for_notify.status);
            break;
        }
        //写入服务端的客户端配置特征值，使能通知，会触发ESP_GATTS_WRITE_EVT事件
        uint16_t notify_en = 1;
        esp_ble_gattc_write_char_descr(
                spp_gattc_if,
                spp_conn_id,
                (db+cmd+1)->attribute_handle,
                sizeof(notify_en),
                (uint8_t *)&notify_en,
                ESP_GATT_WRITE_TYPE_RSP,
                ESP_GATT_AUTH_REQ_NONE);

        break;
    }
    //收到通知事件，服务端 主动推送 Notification（无确认)时触发
    case ESP_GATTC_NOTIFY_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_NOTIFY_EVT");
        notify_event_handler(p_data);
        break;
            
    //读特征值事件，esp_ble_gattc_read_char()后会触发ESP_GATTS_READ_EVT事件，然后esp_ble_gatts_send_response会触发该事件
    case ESP_GATTC_READ_CHAR_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_READ_CHAR_EVT");
        break;
    //写特征值事件，esp_ble_gattc_write_char()触发
    case ESP_GATTC_WRITE_CHAR_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_WRITE_CHAR_EVT:status = %d,handle = %d", param->write.status, param->write.handle);
        if(param->write.status != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG, "ESP_GATTC_WRITE_CHAR_EVT, error status = %d", p_data->write.status);
            break;
        }
        break;
    case ESP_GATTC_PREP_WRITE_EVT:
        break;
    case ESP_GATTC_EXEC_EVT:
        break;
            
    //写入客户端配置特征值完成事件，ESP_GATTC_WRITE_DESCR_EVT 是“打开一个通知开关后的回调”；在这里用队列把下一个特征索引发出去，实现 DATA → STATUS → HEARTBEAT 的串行注册，直到全部启用通知
    case ESP_GATTC_WRITE_DESCR_EVT:
        ESP_LOGI(GATTC_TAG,"ESP_GATTC_WRITE_DESCR_EVT: status =%d,handle = %d", p_data->write.status, p_data->write.handle);
        if(p_data->write.status != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG, "ESP_GATTC_WRITE_DESCR_EVT, error status = %d", p_data->write.status);
            break;
        }
        switch(cmd){
            //注册DATA通知
        case SPP_IDX_SPP_DATA_NTY_VAL:
            cmd = SPP_IDX_SPP_STATUS_VAL;
            xQueueSend(cmd_reg_queue, &cmd,10/portTICK_PERIOD_MS);
            break;
            //注册STATUS通知
        case SPP_IDX_SPP_STATUS_VAL:
#ifdef SUPPORT_HEARTBEAT
            cmd = SPP_IDX_SPP_HEARTBEAT_VAL;
            xQueueSend(cmd_reg_queue, &cmd, 10/portTICK_PERIOD_MS);
#endif
            break;
#ifdef SUPPORT_HEARTBEAT
            //注册 HEARTBEAT 通知
        case SPP_IDX_SPP_HEARTBEAT_VAL:
            xQueueSend(cmd_heartbeat_queue, &cmd, 10/portTICK_PERIOD_MS);
            break;
#endif
        default:
            break;
        };
        break;
       
    //配置最大传输单元事件
    case ESP_GATTC_CFG_MTU_EVT:
        if(p_data->cfg_mtu.status != ESP_OK){
            break;
        }
        ESP_LOGI(GATTC_TAG,"+MTU:%d", p_data->cfg_mtu.mtu);
            
        //记录服务端发来的最大传输单元
        spp_mtu_size = p_data->cfg_mtu.mtu;

        //创建一个数据库，与服务端相比没有声明的枚举
        db = (esp_gattc_db_elem_t *)malloc(count*sizeof(esp_gattc_db_elem_t));
        if(db == NULL){
            ESP_LOGE(GATTC_TAG,"%s:malloc db failed",__func__);
            break;
        }
        //获取数据库
        if(esp_ble_gattc_get_db(spp_gattc_if, spp_conn_id, spp_srv_start_handle, spp_srv_end_handle, db, &count) != ESP_GATT_OK){
            ESP_LOGE(GATTC_TAG,"%s:get db failed",__func__);
            break;
        }
        if(count != SPP_IDX_NB){
            ESP_LOGE(GATTC_TAG,"%s:get db count != SPP_IDX_NB, count = %d, SPP_IDX_NB = %d",__func__,count,SPP_IDX_NB);
            break;
        }
        //根据类型打印数据库
        for(int i = 0;i < SPP_IDX_NB;i++){
            switch((db+i)->type){
            case ESP_GATT_DB_PRIMARY_SERVICE:
                ESP_LOGI(GATTC_TAG,"attr_type = PRIMARY_SERVICE,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_SECONDARY_SERVICE:
                ESP_LOGI(GATTC_TAG,"attr_type = SECONDARY_SERVICE,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_CHARACTERISTIC:
                ESP_LOGI(GATTC_TAG,"attr_type = CHARACTERISTIC,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_DESCRIPTOR:
                ESP_LOGI(GATTC_TAG,"attr_type = DESCRIPTOR,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_INCLUDED_SERVICE:
                ESP_LOGI(GATTC_TAG,"attr_type = INCLUDED_SERVICE,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            case ESP_GATT_DB_ALL:
                ESP_LOGI(GATTC_TAG,"attr_type = ESP_GATT_DB_ALL,attribute_handle=%d,start_handle=%d,end_handle=%d,properties=0x%x,uuid=0x%04x",\
                        (db+i)->attribute_handle, (db+i)->start_handle, (db+i)->end_handle, (db+i)->properties, (db+i)->uuid.uuid.uuid16);
                break;
            default:
                break;
            }
        }
        cmd = SPP_IDX_SPP_DATA_NTY_VAL;
        xQueueSend(cmd_reg_queue, &cmd, 10/portTICK_PERIOD_MS);
        break;
    case ESP_GATTC_SRVC_CHG_EVT:
        break;
    default:
        break;
    }
}
```

### gatts回调

```c
static void esp_gattc_cb(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param)
{
    ESP_LOGI(GATTC_TAG, "EVT %d, gattc if %d", event, gattc_if);

    /* If event is register event, store the gattc_if for each profile */
    if (event == ESP_GATTC_REG_EVT) {
        if (param->reg.status == ESP_GATT_OK) {
            gl_profile_tab[param->reg.app_id].gattc_if = gattc_if;
        } else {
            ESP_LOGI(GATTC_TAG, "Reg app failed, app_id %04x, status %d", param->reg.app_id, param->reg.status);
            return;
        }
    }
    /* If the gattc_if equal to profile A, call profile A cb handler,
     * so here call each profile's callback */
    do {
        int idx;
        for (idx = 0; idx < PROFILE_NUM; idx++) {
            if (gattc_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
                    gattc_if == gl_profile_tab[idx].gattc_if) {
                if (gl_profile_tab[idx].gattc_cb) {
                    gl_profile_tab[idx].gattc_cb(event, gattc_if, param);
                }
            }
        }
    } while (0);
}

```

## 实际使用

### 模型读写

![image-20250718150351308](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507181503505.png)

#### 服务器端

- 自定义一个UUID

  - ```c
    #define TEST_GATT_UUID_LED   0xABF6
    ```

- 定义特征读写权限

  - ```c
    ESP_GATT_CHAR_PROP_BIT_WRITE_NR//客户端写入数据后，不要求服务器回复确认
    ```

  - ```c
    static const uint8_t led_char_prop_read_write_notify = ESP_GATT_CHAR_PROP_BIT_READ|ESP_GATT_CHAR_PROP_BIT_WRITE_NR|ESP_GATT_CHAR_PROP_BIT_NOTIFY;
    ```

- 定义特征服务

  - ```c
    static const uint16_t test_led_uuid = TEST_GATT_UUID_LED;
    static const uint8_t  test_led_val[1] = {0x00};//状态
    static const uint8_t  test_led_ccc[2] = {0x00, 0x00};//客户端配置
    ```

- 添加蓝牙 GATT（Generic Attribute Profile）服务定义 的索引值，包括属性的声明, 值和描述符

  - ```c
    enum{
        SPP_IDX_SVC,
    
        SPP_IDX_SPP_DATA_RECV_CHAR,
        SPP_IDX_SPP_DATA_RECV_VAL,
    
        SPP_IDX_SPP_DATA_NOTIFY_CHAR,
        SPP_IDX_SPP_DATA_NTY_VAL,
        SPP_IDX_SPP_DATA_NTF_CFG,
    
        SPP_IDX_SPP_COMMAND_CHAR,
        SPP_IDX_SPP_COMMAND_VAL,
    
        SPP_IDX_SPP_STATUS_CHAR,
        SPP_IDX_SPP_STATUS_VAL,
        SPP_IDX_SPP_STATUS_CFG,
    
    #ifdef SUPPORT_HEARTBEAT
        SPP_IDX_SPP_HEARTBEAT_CHAR,
        SPP_IDX_SPP_HEARTBEAT_VAL,
        SPP_IDX_SPP_HEARTBEAT_CFG,
    #endif
    
    #ifdef SUPPORT_LED
        TEST_LED_CHAR,
        TEST_LED_VAL,
        TEST_LED_CFG,
    #endif
    
        SPP_IDX_NB,
    };
    ```

- 添加GATT数据表库

  - ```c
    #ifdef SUPPORT_LED
        [TEST_LED_CHAR] =                                   //0x2803    特征声明
        {{ESP_GATT_AUTO_RSP},{ESP_UUID_LEN_16,(uint8_t *)&character_declaration_uuid,ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
        CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE,(uint8_t*)&led_char_prop_read_write_notify}},
    
        [TEST_LED_VAL] =                                    //x0ABF6 自定义UUID
        {{ESP_GATT_AUTO_RSP},{ESP_UUID_LEN_16,(uint8_t *)&test_led_uuid,ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
        sizeof(uint8_t),sizeof(test_led_val),(uint8_t*)test_led_val}},
    
        [TEST_LED_CFG] =                                    //0x2902    客户端配置特征
        {{ESP_GATT_AUTO_RSP},{ESP_UUID_LEN_16,(uint8_t *)&character_client_config_uuid,ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
        sizeof(uint8_t),sizeof(test_led_ccc),(uint8_t*)test_led_ccc}}
    #endif
    
    ```

- 写入特征值，在gatts回调函数里面的ESP_GATTS_WRITE_EVT事件下面

  - esp_ble_gatts_set_attr_value函数来设定特征值

  - 写入完成后会进入ESP_GATTS_SET_ATTR_VAL_EVT这一个事件

  - ```c
    #ifdef SUPPORT_LED               
                    else if(res == TEST_LED_VAL)
                    {
                        //将要写入的值写入LED特征值
                        if(esp_ble_gatts_set_attr_value(p_data->write.handle,p_data->write.len,p_data->write.value) == ESP_OK)
                        {
                            //写入成功
                        }
                        else
                        {
                            //写入失败
                        }
                    }
    #endif  
    ```

    

- 编写写入特征值完成事件，在gatts回调中

  - ```c
    #ifdef SUPPORT_LED
            //设置属性值完成事件
            case ESP_GATTS_SET_ATTR_VAL_EVT:
            // 找到属性表下标
            res = find_char_and_desr_index(p_data->set_attr_val.attr_handle);
            
            if(res == TEST_LED_VAL)
            {
                xQueueSend(led_queue,&p_data->set_attr_val.status,10/portTICK_PERIOD_MS);
            }
            break;
    #endif
    ```

- 编写新的任务，比如led_task

  - ```c
    #ifdef SUPPORT_LED
    static QueueHandle_t led_queue = NULL;
    #endif
    
    #ifdef SUPPORT_LED
        led_queue = xQueueCreate(1, sizeof(uint8_t));
        xTaskCreate(led_task, "led_task", 2048, NULL, 10, NULL);
    #endif
    
    
    #ifdef SUPPORT_LED
    void led_task(void * arg)
    {
        const uint8_t *led_value = NULL;
        uint16_t len;
        uint8_t set_status = 0;
    
        //初始化LED
        /*
            todo
        */
    
    
        for(;;) {
            vTaskDelay(50 / portTICK_PERIOD_MS);
            //等待LED特征值被写入
            if(xQueueReceive(led_queue, &set_status, portMAX_DELAY)) {
                while(1){   
                    //写入特征值成功
                    if(set_status == ESP_GATT_OK)
                    {
                        if(esp_ble_gatts_get_attr_value(spp_handle_table[TEST_LED_VAL],&len,&led_value) != ESP_OK)
                        {
                            //获取LED特征值失败
                        }
                        else
                        {
                            //获取LED特征值成功
                            //控制LED函数
                        }
                    }
    #ifdef SUPPORT_NOTIFY
                    //如果通知或者指示标志位开启，就发送通知或者指示
                    //false 发送GATT通知，true发送GATT指示
                    if(flag == 1 || flag ==2)
                        esp_ble_gatts_send_indicate(spp_gatts_if,spp_conn_id,spp_handle_table[TEST_LED_VAL],sizeof(uint8_t),
                    led_value,flag == 1?false:true);
    
    #endif
    
                }
            }
        }
        vTaskDelete(NULL);
    }
    #endif
    
    ```

    

#### 客户端写入

- 添加服务定义 的索引值

  - ```c
    enum{
        SPP_IDX_SVC,
    
        SPP_IDX_SPP_DATA_RECV_VAL,
    
        SPP_IDX_SPP_DATA_NTY_VAL,
        SPP_IDX_SPP_DATA_NTF_CFG,
    
        SPP_IDX_SPP_COMMAND_VAL,
    
        SPP_IDX_SPP_STATUS_VAL,
        SPP_IDX_SPP_STATUS_CFG,
    
    #ifdef SUPPORT_HEARTBEAT
        SPP_IDX_SPP_HEARTBEAT_VAL,
        SPP_IDX_SPP_HEARTBEAT_CFG,
    #endif
    
    #ifdef SUPPORT_LED
        TEST_LED_VAL,
        TEST_LED_CFG,
    #endif
    
        SPP_IDX_NB,
    };
    ```

- 添加任务

  - ```c
    #ifdef SUPPORT_LED
        xTaskCreate(led_task, "led_task", 2048, NULL, 10, NULL);
    #endif
    
    #ifdef SUPPORT_LED
    void led_task(void* arg)
    {
        uint8_t status = 0;
        for(;;)
        {
            vTaskDelay(1000/portTICK_PERIOD_MS);
            //判断连接状态，数据库是否存在，以及权限
            if((is_connect == true) && (db != NULL) && ((db+TEST_LED_VAL)->properties & (ESP_GATT_CHAR_PROP_BIT_WRITE_NR | ESP_GATT_CHAR_PROP_BIT_WRITE)))
            {
                //写入LED特征值，这个会触发gattc的ESP_GATTC_WRITE_CHAR_EVT事件,然后如果向服务端发送写请求的话会触发ESP_GATTS_WRITE_EVT事件
                esp_ble_gattc_write_char(spp_gattc_if,spp_conn_id,(db+TEST_LED_VAL)->attribute_handle,sizeof(status),(uint8_t *)&status,ESP_GATT_WRITE_TYPE_RSP,ESP_GATT_AUTH_REQ_NONE);
    
                status++;
                status%=2;
                vTaskDelay(1000/portTICK_PERIOD_MS);
            }
        }
    }
    #endif
    ```

    

#### 客户端读取

- 在注册表里面添加自己的属性(下标, 描述符)

- 连接以后可以使用esp_ble_gattc_read_char函数读取特征值，这个函数会触发gatts的ESP_GATTS_READ_EVT事件，然后esp_ble_gatts_send_response会触发ESP_GATTC_READ_CHAR_EVT事件，表示读取完成事件，用户可以在该事件下进行读取数据的处理

  - ```c
    //判断是否读取成功
    if(p_data->read.status == ESP_GATT_OK)
    {
        //判断属性句柄句柄
        if(p_data->read.handle == (db+TEST_LED_VAL)->attribute_handle)//判断一下读取的属性
        {
            printf("read value = %d,len = %d\r\n",*p_data->read.value,p_data->read.value_len);
            memcpy(&read_status,p_data->read.value,p_data->read.value_len);
        }
    }
    ```

    

### 模型通知

![image-20250718160341908](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507181603104.png)

#### 服务端

- 编写ESP_GATTS_WRITE_EVT事件，由客户端的esp_ble_gattc_write_char_descr触发，获取客户端的通知请求

  - ```c
                    else if(res == TEST_LED_CFG)
                    {
                        flag = *p_data->write.value;
                    }
    ```

- 发送通知

  - ```c
    //如果通知或者指示标志位开启，就发送通知或者指示
    //false 发送GATT通知，true发送GATT指示
    if(flag == 1 || flag ==2)
    esp_ble_gatts_send_indicate(spp_gatts_if,spp_conn_id,spp_handle_table[TEST_LED_VAL],sizeof(uint8_t),
                        		led_value,flag == 1?false:true);
    ```

  - 后客户端会进入ESP_GATTC_NOTIFY_EVT这一个事件里面(需要注册这一个句柄的通知)

#### 客户端

- 使用esp_ble_gattc_register_for_notify()函数注册一个通知，绑定一个属性表的特征值

- 给某一个属性表的特征值注册一个通知, 之后就可以获这一个属性表的特征值的通知, 但是注册的时候不会对服务端进行通知, 需要在ESP_GATTC_REG_FOR_NOTIFY_EVT里面自己通知

  - ```c
    esp_ble_gattc_register_for_notify(spp_gattc_if,gl_profile_tab[PROFILE_APP_ID].remote_bda,
                                             (db+TEST_LED_VAL)->attribute_handle);
    ```

- 编写ESP_GATTC_REG_FOR_NOTIFY_EVT事件内容

  - 使用esp_ble_gattc_write_char_descr来向服务端发送请求

    ```c
    //写入服务端的客户端配置特征值，使能通知，会触发ESP_GATTS_WRITE_EVT事件            
    uint16_t notify_en = 1;
    esp_ble_gattc_write_char_descr(spp_gattc_if,
                                   spp_conn_id,
                                   (db+TEST_LED_CFG)->attribute_handle,
                                   sizeof(notify_en),
                                   (uint8_t *)&notify_en,
                                   ESP_GATT_WRITE_TYPE_RSP,
                                   ESP_GATT_AUTH_REQ_NONE);
    ```

- 服务端调用esp_ble_gatts_send_indicate函数触发ESP_GATTC_NOTIFY_EVT，在ESP_GATTC_NOTIFY_EVT事件里面处理收到的通知

  - ```c
    handle = p_data->notify.handle;  	
    	if(handle == ((db+TEST_LED_VAL)->attribute_handle))
        {
            if(p_data->notify.value_len == sizeof(uint8_t))
            {
                //获取通知
                flag = *(uint8_t *)p_data->notify.value;
            }
        }
    ```

## API函数

### 注册通知

```c
esp_err_t esp_ble_gattc_register_for_notify(esp_gatt_if_t gattc_if, esp_bd_addr_t server_bda, uint16_t handle);
//GATT 客户端接口编号,调用esp_ble_gattc_app_register(uint16_t app_id)函数之后会在ESP_GATTC_REG_EVT 里面返回一个gattc_if
//对端设备地址（MAC）
// 要监听通知的特征值句柄
```

### 服务器发送通知/指示

```c
esp_err_t esp_ble_gatts_send_indicate(esp_gatt_if_t gatts_if, uint16_t conn_id, uint16_t attr_handle, uint16_t value_len, uint8_t *value, bool need_confirm);
//会触发ESP_GATTC_NOTIFY_EVT事件 
//need_confirm 1为指示，0为通知

if(flag == 1 || flag ==2)
esp_ble_gatts_send_indicate(spp_gatts_if,spp_conn_id,spp_handle_table[TEST_LED_VAL],sizeof(uint8_t),
                    		led_value,flag == 1?false:true);
```

### 写入描述符数据

```c
esp_ble_gattc_write_char_descr(
    spp_gattc_if,	//客户端接口id
    spp_conn_id,	//连接id
    (db+TEST_LED_CFG)->attribute_handle,//描述符句柄（不是特征值句柄）
    sizeof(notify_en),//待写数据长度
    (uint8_t *)&notify_en,//待写数据
    ESP_GATT_WRITE_TYPE_RSP,//写类型：ESP_GATT_WRITE_TYPE_REQ / NO_RSP
    ESP_GATT_AUTH_REQ_NONE);//认证要求：ESP_GATT_AUTH_REQ_NONE 等

//最常用动作是 打开/关闭 notify 或 indicate
```

### 客户端读取

会触发ESP_GATTS_READ_EVT事件

esp_ble_gatts_send_response会触发ESP_GATTC_READ_CHAR_EVT事件

```c
esp_err_t esp_ble_gattc_read_char(esp_gatt_if_t gattc_if, uint16_t conn_id, uint16_t handle, esp_gatt_auth_req_t auth_req);
```

### 服务器回应

**GATT 服务端** 用来 **向客户端回送“响应”或“确认”** 的函数。

```c
esp_err_t esp_ble_gatts_send_response(
    esp_gatt_if_t gatts_if,     // 服务端接口 id
    uint16_t conn_id,           // 连接 id
    uint32_t trans_id,          // 事务 id（来自请求事件参数）
    esp_gatt_status_t status,   // 状态码：ESP_GATT_OK / ESP_GATT_ERROR …
    esp_gatt_rsp_t *rsp         // 响应数据（读操作需要填；写操作可 NULL）
);
```

### 获取服务

- 向远端 GATT 服务器 **发起服务发现请求**。
- 搜索完成后，会依次触发：
  - `ESP_GATTC_SEARCH_RES_EVT`：每找到一个服务触发一次。
  - `ESP_GATTC_SEARCH_CMPL_EVT`：全部搜索完成触发一次。

```c
esp_err_t esp_ble_gattc_search_service(
    esp_gatt_if_t gattc_if,      // GATT 客户端接口 ID
    uint16_t conn_id,            // 当前连接的 ID
    esp_bt_uuid_t *filter_uuid   // 指定要搜索的服务 UUID（可设为 NULL 搜索全部）
);
```

```c
    //每找到一个服务触发一次
    case ESP_GATTC_SEARCH_RES_EVT:
        ESP_LOGI(GATTC_TAG, "ESP_GATTC_SEARCH_RES_EVT: start_handle = %d, end_handle = %d, UUID:0x%04x",p_data->search_res.start_handle,p_data->search_res.end_handle,p_data->search_res.srvc_id.uuid.uuid.uuid16);
        //记录服务端的Handle数据
        spp_srv_start_handle = p_data->search_res.start_handle;
        spp_srv_end_handle = p_data->search_res.end_handle;
        break;
    
    //全部搜索完成触发一次
    case ESP_GATTC_SEARCH_CMPL_EVT:
        ESP_LOGI(GATTC_TAG, "SEARCH_CMPL: conn_id = %x, status %d", spp_conn_id, p_data->search_cmpl.status);
        //发送最大传输单元，之后进入ESP_GATTC_CFG_MTU_EVT事件
        esp_ble_gattc_send_mtu_req(gattc_if, spp_conn_id);
        break;
```

### 获取数据库

```c
esp_gatt_status_t esp_ble_gattc_get_db(
    esp_gatt_if_t gattc_if,        // GATT 客户端接口
    uint16_t conn_id,              // 连接 ID
    uint16_t start_handle,         // 起始句柄（通常填由获取服务函数得到的start_handle）
    uint16_t end_handle,           // 结束句柄（通常填由获取服务函数得到的end_handle）
    esp_gattc_db_elem_t *db,       // 输出：数据库条目数组
    uint16_t *count                // 输入/输出：数组元素数
);
```

### 开启gatt

用于替代旧版 `esp_ble_gattc_open` / `esp_ble_gattc_aux_open`，可以统一兼容 **BLE 4.2 与 BLE 5.0** 功能

```c
esp_err_t esp_ble_gattc_enh_open(
    esp_gatt_if_t                     gattc_if,
    esp_ble_gatt_creat_conn_params_t *create_conn
);
```

```c
            esp_ble_gatt_creat_conn_params_t creat_conn_params = {0};
            //获取远程服务端的信息
            memcpy(&creat_conn_params.remote_bda, scan_rst.scan_rst.bda,ESP_BD_ADDR_LEN);
            creat_conn_params.remote_addr_type = scan_rst.scan_rst.ble_addr_type;
            creat_conn_params.own_addr_type = BLE_ADDR_TYPE_PUBLIC;
            creat_conn_params.is_direct = true;
            creat_conn_params.is_aux = false;
            creat_conn_params.phy_mask = 0x0;
            //建立连接
            esp_ble_gattc_enh_open(gl_profile_tab[PROFILE_APP_ID].gattc_if,
                                &creat_conn_params);
```

### 设置/获取属性的值

```c
//会触发ESP_GATTS_SET_ATTR_VAL_EVT事件
esp_err_t esp_ble_gatts_set_attr_value(uint16_t attr_handle, uint16_t length, const uint8_t *value);


esp_gatt_status_t esp_ble_gatts_get_attr_value(uint16_t attr_handle, uint16_t *length, const uint8_t **value);
```

# 蓝牙SMP安全配对

要实现SMP安全配对还是要依赖于GATT和ATT这种客户端与服务端的模型

![image-20250720151900546](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201519621.png)

![image-20250720151917117](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201519197.png)

## 专业术语

**Paring（配对）**，配对包括配对能力交换，设备认证，密钥生成，连接加密以及机密信息分发等过程，配对的目的有三个：加密连接，认证设备，以及生成密钥。

**Bonding（绑定）**，配对过程中会生成一个长期密钥（LTK，long-term Key），如果配对双方把这个LTK存储起来放在Flash中，那么这两个设备再次重连的时候，就可以跳过配对流程，而直接使用LTK对蓝牙连接进行加密，设备的这种状态称为bonding。如果paring过程中不存储LTK（不分发LTK）也是可以的，paring完成后连接也是加密的，但是如果两个设备再次重连，那么就需要重走一次paring流程，否则两者还是明文通信。在不引起误解的情况下，我们经常把paring当成paring和 bonding两者的组合，因为只paring不bonding的应用情况非常少见。在不引起混淆的情况下，下文就不区分paring和bonding的区别，换句话说，我们会把paring和bonding两个概念等同起来进行混用。

**SM（security manager）**，蓝牙协议栈的安全管理层，规定了跟蓝牙安全通信有关的所有要素，包括paring，bonding，以及下文提到的SMP。

**SMP（security manager protocol）**，安全管理协议，SMP着重两个设备之间的蓝牙交互命令序列，对paring的空中包进行了严格时序规定。类似于iic和spi，就是一种协议

**OOB（out of band，带外）**，OOB就是不通过蓝牙射频本身来交互，而是通过比如人眼，NFC，UART等带外方式来交互配对信息，在这里人眼，NFC，UART通信方式就被称为OOB通信方式。

**Passkey（又称pin码）**，是指用户在键盘中输入的一串数字，以达到认证设备的目的。低功耗蓝牙的passkey必须为6位。

**Numeric comparison（数字比较）**，numeric comparison其实跟passkey一样，也是用来认证设备的，只不过passkey是通过键盘输入的，而numeric comparison是显示在显示器上的，numericcomparison也必须是6位的数字。

**justwork**: 不进行认证, 直接进行连接

**MITM（man in the middle）**，MITM是指A和B通信过程中，C会插入进来以模拟A或者B，并且具备截获和篡改A和B之间所有通信报文的能力，从而达到让A或者B信任它，以至于错把C当成B或者A来通信。如果对安全要求比较高，需要具备MITM保护能力，在SM中这个是通过认证（authentication）来实现的，SM中实现认证的方式有三种：OOB认证信息，passkey以及numeric comparison，大家根据自己的实际情况，选择其中一种即可。

**LESC（LE security connections）**- 新式配对，又称SC，蓝牙4.2引入的一种新的密钥生成方式和验证方式，SC通过基于椭圆曲线的Diffie-Hellman密钥交换算法来生成设备A和B的共享密钥，此密钥生成过程中需要用到公私钥对，以及其他的密码算法库。LESC同时还规定了相应的通信协议以生成该密钥，并验证该密钥。需要注意的是LESC对paring的其他方面也会产生一定的影响，所以我们经常会把LESC看成是一种新的配对方式。

**Legacy paring - 老式配对**，在LESC引入之前的密钥生成方式，称为legacy paring，换句话说，legacy paring是相对LESC来说的，不支持LESC的配对即为legacy paring（legacy配对）。

**TK（Temporary Key，临时密钥）**，legacy paring里面的概念，如果采用just work配对方式，TK就是为全0；如果采用passkey配对方式，TK就是passkey；如果采用OOB配对方式，TK就是OOB里面的信息。

**STK（short term key，短期密钥）**，legacy配对里面的概念，STK是通过TK推导出来的，通过TK对设备A和B的随机数进行加密，即得到STK。

**LTK（long term key，长期密钥）**，legacy配对和LESC配对都会用到LTK，如前所述，LTK是用来对未来的连接进行加密和解密用的。Legacy paring中的LTK由从设备根据相应的算法自己生成的（LTK生成过程中会用到EDIV（分散因子）和Rand（随机数）），然后通过蓝牙空中包传给主机。LESC配对过程中，先通过Diffie-Hellman生成一个共享密钥，然后这个共享密钥再对设备A和B的蓝牙地址和随机数进行加密，从而得到LTK，LTK由设备A和B各自同时生成，因此LTK不会出现在LESC蓝牙空中包中，大大提高了蓝牙通信的安全性。

**IRK（Identity Resolving Key，蓝牙设备地址解析密钥）**，有些蓝牙设备的地址为可解析的随机地址，比如iPhone手机，由于他们的地址随着时间会变化，那如何确定这些变化的地址都来自同一个设备呢？答案就是IRK，IRK通过解析变化的地址的规律，从而确定这些地址是否来自同一个设备，换句话说，IRK可以用来识别蓝牙设备身份，因此其也称为Identity information。IRK一般由设备出厂的时候按照一定要求自动生成。

**Identity Address（设备唯一地址）**，蓝牙设备地址包括public，random static， privateresolvable，random unresolved共四类。如果设备不支持privacy，那么identity address就等于public或者random static设备地址。如果设备支持privacy，即使用private resolvable蓝牙设备地址，在这种情况下，虽然其地址每隔一段时间会变化一次，但是identity address仍然保持不变，其取值还是等于内在的public或者random static设备地址。Identity Address和IRK都可以用来唯一标识一个蓝牙设备。

**IO capabilities（输入输出能力）**，是指蓝牙设备的输入输出能力，比如是否有键盘，是否有显示器，是否可以输入Yes/No两个确认值。

**Key size（密钥长度）**，一般来说，密钥默认长度为16字节，为了适应一些低端的蓝牙设备处理 能力，你也可以把密钥长度调低，比如变为10个字节。

## 认证要求

![image-20250720152835515](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201528589.png)

### IO能力

![image-20250720152849939](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201528019.png)

### 配对方法

响应端一般是服务器

发起端一般是客户端

![image-20250720152857651](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201528727.png)

![image-20250720152904992](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201529066.png)

![image-20250720152911696](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201529773.png)

## 示例代码分析

![image-20250720153742962](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201537039.png)

### SMP设置安全参数

![image-20250720153836837](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201538924.png)

### 服务端事件回调

#### gatts

![image-20250720154651395](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201546488.png)

#### gap

![image-20250720154701935](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201547043.png)

### 客户端事件回调

#### gattc

![image-20250720155319838](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201553364.png)

#### gap

![image-20250720155801362](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201558483.png)

**打印绑定设备地址之后会触发密钥分发事件**

## 代码实现

![image-20250720171235117](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201712224.png)

### 初始化

```c
void app_main(void)
{
    esp_err_t ret;

    // Initialize NVS.
    ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );

    #if CONFIG_EXAMPLE_CI_PIPELINE_ID
    memcpy(example_device_name, esp_bluedroid_get_example_name(), ESP_BLE_ADV_NAME_LEN_MAX);
    #endif

    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));

    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    esp_bt_controller_init(&bt_cfg);
    esp_bt_controller_enable(ESP_BT_MODE_BLE);
    esp_bluedroid_init();
    esp_bluedroid_enable();
    esp_ble_gatts_register_callback(gatts_event_handler);
	esp_ble_gap_register_callback(gap_event_handler);
    esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID);


    //配置 ESP32 的 BLE 安全参数，用于设置设备在配对过程中的认证方式、IO 能力、密钥长度、密钥类型、静态 PIN 码等

    //设置认证要求
    // #define ESP_LE_AUTH_NO_BOND                 0x00        //无绑定：下次重连必须重新配对，不强制MTIM保护：只要对方愿意，可以使用justWorks，不强制安全连接
    // #define ESP_LE_AUTH_BOND                    0x01        //只要求绑定：配对成功后把 LTK/CSRK/IRK 等写到 Flash，下次重连直接加密，不再弹配对框
    // #define ESP_LE_AUTH_REQ_MITM                (1 << 2)    //是要求MITM保护（防中间人攻击），协议栈会拒绝 Just Works；必须选 Passkey/Numeric Comparison/OOB 之一
                                                               //如果双方 IO 能力都是 NoInputNoOutput → 配对直接失败
    // #define ESP_LE_AUTH_REQ_BOND_MITM           (ESP_LE_AUTH_BOND | ESP_LE_AUTH_REQ_MITM) //既要绑定，又要MITM保护，配对成功后存密钥
    // #define ESP_LE_AUTH_REQ_SC_ONLY             (1 << 3)                                  //只要求安全连接，如果对方不支持 SC → 配对失败
    // #define ESP_LE_AUTH_REQ_SC_BOND             (ESP_LE_AUTH_BOND | ESP_LE_AUTH_REQ_SC_ONLY)            //要求安全连接和绑定，配对成功后存密钥，必须对方也是安全连接
    // #define ESP_LE_AUTH_REQ_SC_MITM             (ESP_LE_AUTH_REQ_MITM | ESP_LE_AUTH_REQ_SC_ONLY)        //安全连接和MITM，不要求绑定 → 下次连接需重新配对
    // #define ESP_LE_AUTH_REQ_SC_MITM_BOND        (ESP_LE_AUTH_REQ_MITM | ESP_LE_AUTH_REQ_SC_ONLY | ESP_LE_AUTH_BOND)   //都要
    esp_ble_auth_req_t auth_req = ESP_LE_AUTH_REQ_SC_MITM_BOND;     //安全连接，绑定，MITM都要


    //配置IO功能，会影响是否能够启用防MITM功能
    // #define ESP_IO_CAP_OUT                      0   /*!< DisplayOnly */
    // #define ESP_IO_CAP_IO                       1   /*!< DisplayYesNo */
    // #define ESP_IO_CAP_IN                       2   /*!< KeyboardOnly */
    // #define ESP_IO_CAP_NONE                     3   /*!< NoInputNoOutput */
    // #define ESP_IO_CAP_KBDISP                   4   /*!< Keyboard display */
    esp_ble_io_cap_t iocap = ESP_IO_CAP_NONE;           //由于没有IO能力，所以不能开启MITM，只能Just Works

    uint8_t key_size = 16;      //the key size should be 7~16 bytes
    //配置在 BLE 配对过程中，本机（initiator）和对端（responder）需要向对方“分发”哪些长期密钥。
    //LTK：给对方用于后续链路加密
    //IRK：让对方能解析你的私有地址，保持绑定后地址不变
    uint8_t init_key = ESP_BLE_ENC_KEY_MASK | ESP_BLE_ID_KEY_MASK;//发起者密钥，给对方发送LTK和IRK
    uint8_t rsp_key = ESP_BLE_ENC_KEY_MASK | ESP_BLE_ID_KEY_MASK;//响应者密钥，接收LTK和IRK

    //设置静态密钥
    uint32_t passkey = 123456;

    //是否让对端只接受本端显式指定的配对方式
    uint8_t auth_option = ESP_BLE_ONLY_ACCEPT_SPECIFIED_AUTH_DISABLE;//不限制对端必须使用本端“显式声明”的配对模型，即可协商
    //是否启用 Out-of-Band（OOB）配对通道（如 NFC、二维码等）
    uint8_t oob_support = ESP_BLE_OOB_DISABLE;//不启用 OOB 通道，不走 NFC/二维码，纯空中配对（Just Works / Passkey / Numeric Comparison）。
    //设置静态密钥
    esp_ble_gap_set_security_param(ESP_BLE_SM_SET_STATIC_PASSKEY, &passkey, sizeof(uint32_t));
    //设置认证方式为BOND+SC+MITM
    esp_ble_gap_set_security_param(ESP_BLE_SM_AUTHEN_REQ_MODE, &auth_req, sizeof(uint8_t));
    //设置IO能力为无IO
    esp_ble_gap_set_security_param(ESP_BLE_SM_IOCAP_MODE, &iocap, sizeof(uint8_t));
    //设置最大加密密钥长度
    esp_ble_gap_set_security_param(ESP_BLE_SM_MAX_KEY_SIZE, &key_size, sizeof(uint8_t));
    //不限制对端必须使用本端“显式声明”的配对模型
    esp_ble_gap_set_security_param(ESP_BLE_SM_ONLY_ACCEPT_SPECIFIED_SEC_AUTH, &auth_option, sizeof(uint8_t));
    //关闭OOB配对
    esp_ble_gap_set_security_param(ESP_BLE_SM_OOB_SUPPORT, &oob_support, sizeof(uint8_t));
    /* If your BLE device acts as a Slave, the init_key means you hope which types of key of the master should distribute to you,
    and the response key means which key you can distribute to the master;
    If your BLE device acts as a master, the response key means you hope which types of key of the slave should distribute to you,
    and the init key means which key you can distribute to the slave. */ 
    //设置密钥类型
    esp_ble_gap_set_security_param(ESP_BLE_SM_SET_INIT_KEY, &init_key, sizeof(uint8_t));
    esp_ble_gap_set_security_param(ESP_BLE_SM_SET_RSP_KEY, &rsp_key, sizeof(uint8_t));

    /* Just show how to clear all the bonded devices
     * Delay 30s, clear all the bonded devices
     *
     * vTaskDelay(30000 / portTICK_PERIOD_MS);
     * remove_all_bonded_devices();
     */
}

```

### 服务端gap

```c
//密钥请求事件
case ESP_GAP_BLE_PASSKEY_REQ_EVT:                           /* passkey request event */
    ESP_LOGI(GATTS_TABLE_TAG, "Passkey request");
    /* Call the following function to input the passkey which is displayed on the remote device */
    //esp_ble_passkey_reply(heart_rate_profile_tab[HEART_PROFILE_APP_IDX].remote_bda, true, 0x00);
    break;
//带外数据请求事件，如果使用了oob，那么客户端和服务端都需要输入一个相同的数
case ESP_GAP_BLE_OOB_REQ_EVT: {
    ESP_LOGI(GATTS_TABLE_TAG, "OOB request");
    uint8_t tk[16] = {1}; //If you paired with OOB, both devices need to use the same tk
    esp_ble_oob_req_reply(param->ble_security.ble_req.bd_addr, tk, sizeof(tk));
    break;
}
//数字比较事件 - 安全配对的模式下面才有, 具体的设备需要看两方的输入输出
case ESP_GAP_BLE_NC_REQ_EVT:
/* The app will receive this evt when the IO has DisplayYesNO capability and the peer device IO also has DisplayYesNo capability.
        show the passkey number to the user to confirm it with the number displayed by peer device. */
esp_ble_confirm_reply(param->ble_security.ble_req.bd_addr, true);
ESP_LOGI(GATTS_TABLE_TAG, "ESP_GAP_BLE_NC_REQ_EVT, the passkey Notify number:%d", (int)param->ble_security.key_notif.passkey);
count_printf("ESP_GAP_BLE_NC_REQ_EVT");
break;
//安全请求
case ESP_GAP_BLE_SEC_REQ_EVT:
/* send the positive(true) security response to the peer device to accept the security request.
        If not accept the security request, should send the security response with negative(false) accept value*/
esp_ble_gap_security_rsp(param->ble_security.ble_req.bd_addr, true);
count_printf("ESP_GAP_BLE_SEC_REQ_EVT");
break;
//密钥显示通知
case ESP_GAP_BLE_PASSKEY_NOTIF_EVT:  ///the app will receive this evt when the IO  has Output capability and the peer device IO has Input capability.
///show the passkey number to the user to input it in the peer device.
ESP_LOGI(GATTS_TABLE_TAG, "The passkey Notify number:%06d", (int)param->ble_security.key_notif.passkey);
count_printf("ESP_GAP_BLE_PASSKEY_NOTIF_EVT");
break;
//对方设备密钥
case ESP_GAP_BLE_KEY_EVT:
//shows the ble key info share with peer device to the user.
ESP_LOGI(GATTS_TABLE_TAG, "key type = %s", esp_key_type_to_str(param->ble_security.ble_key.key_type));
count_printf("ESP_GAP_BLE_KEY_EVT");
break;
//认证完成
case ESP_GAP_BLE_AUTH_CMPL_EVT: {
    esp_bd_addr_t bd_addr;
    //记录一下地址
    memcpy(bd_addr, param->ble_security.auth_cmpl.bd_addr, sizeof(esp_bd_addr_t));
    ESP_LOGI(GATTS_TABLE_TAG, "remote BD_ADDR: %08x%04x",\
             (bd_addr[0] << 24) + (bd_addr[1] << 16) + (bd_addr[2] << 8) + bd_addr[3],
             (bd_addr[4] << 8) + bd_addr[5]);
    ESP_LOGI(GATTS_TABLE_TAG, "address type = %d", param->ble_security.auth_cmpl.addr_type);
    ESP_LOGI(GATTS_TABLE_TAG, "pair status = %s",param->ble_security.auth_cmpl.success ? "success" : "fail");
    if(!param->ble_security.auth_cmpl.success) {
        ESP_LOGI(GATTS_TABLE_TAG, "fail reason = 0x%x",param->ble_security.auth_cmpl.fail_reason);
    } else {
        ESP_LOGI(GATTS_TABLE_TAG, "auth mode = %s",esp_auth_req_to_str(param->ble_security.auth_cmpl.auth_mode));
    }
    //显示绑定的设备的id
    show_bonded_devices();
    //		remove_all_bonded_devices();
    count_printf("ESP_GAP_BLE_AUTH_CMPL_EVT");
    break;
}
case ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT: {
    ESP_LOGD(GATTS_TABLE_TAG, "ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT status = %d", param->remove_bond_dev_cmpl.status);
    ESP_LOGI(GATTS_TABLE_TAG, "ESP_GAP_BLE_REMOVE_BOND_DEV");
    ESP_LOGI(GATTS_TABLE_TAG, "-----ESP_GAP_BLE_REMOVE_BOND_DEV----");
    esp_log_buffer_hex(GATTS_TABLE_TAG, (void *)param->remove_bond_dev_cmpl.bd_addr, sizeof(esp_bd_addr_t));
    ESP_LOGI(GATTS_TABLE_TAG, "------------------------------------");
    count_printf("ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT");
    break;
}
case ESP_GAP_BLE_SET_LOCAL_PRIVACY_COMPLETE_EVT:
if (param->local_privacy_cmpl.status != ESP_BT_STATUS_SUCCESS){
    ESP_LOGE(GATTS_TABLE_TAG, "config local privacy failed, error status = %x", param->local_privacy_cmpl.status);
    break;
}

esp_err_t ret = esp_ble_gap_config_adv_data(&heart_rate_adv_config);
if (ret){
    ESP_LOGE(GATTS_TABLE_TAG, "config adv data failed, error code = %x", ret);
}else{
    adv_config_done |= ADV_CONFIG_FLAG;
}

ret = esp_ble_gap_config_adv_data(&heart_rate_scan_rsp_config);
if (ret){
    ESP_LOGE(GATTS_TABLE_TAG, "config adv data failed, error code = %x", ret);
}else{
    adv_config_done |= SCAN_RSP_CONFIG_FLAG;
}
count_printf("ESP_GAP_BLE_SET_LOCAL_PRIVACY_COMPLETE_EVT");
break;
```

### 服务端gatts

```c
//连接事件
case ESP_GATTS_CONNECT_EVT:
            ESP_LOGI(GATTS_TABLE_TAG, "Connected, conn_id %u, remote "ESP_BD_ADDR_STR"",
                     param->connect.conn_id, ESP_BD_ADDR_HEX(param->connect.remote_bda));
            //主动向刚连上的远端设备发起 加密/配对流程。
		   //如果远端设备 不支持或不接受 这个安全级别，连接最终会在配对阶段被断开，你需要在 ESP_GAP_BLE_AUTH_CMPL_EVT 里处理失败原因
            esp_ble_set_encryption(param->connect.remote_bda, ESP_BLE_SEC_ENCRYPT_MITM);
            break;
```

# 蓝牙HID

- HID（Human Interface Device，人机接口设备），是USB设备中常用的设备类型，是直接与人交互的USB设备，例如键盘，鼠标，游戏手柄等
- HID设备不一定要有人机交互功能，只要符合HID规范就行
- Wndows操作系统最先支持的HID设备。在windows 98以及后来的版本中内置有HID设备的驱动程序，应用程序可以直接使用这些驱动程序来与设备通信
- 在设计一个 USB 接口的计算机外部设备时，如果 HID 类型的设备可以满足需要，可以将其设计为 HID 类型设备，这样可以省去比较复杂的 USB 驱动程序的编写，直接利用Windows 操作系统对标准的 HID 类型 USB 设备的支持。
- 对接就是用使用的是HOGP协议



## HOGP协议

![image-20250720180814157](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201808279.png)

### HOGP作用

USB Host就相当于windows电脑

蓝牙Device就是键盘，鼠标等

![image-20250720181505065](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201815149.png)

## 蓝牙HID

### HID角色和服务关系

HID Host就相当于windows电脑

蓝牙HID Device就是键盘，鼠标等

![image-20250720181734715](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201817802.png)

### HID设备服务

- 硬件本地化跟国家有关系，不同的地区有不同的表示
- 协议模式一般使用报告模式
- 控制点可选，是否支持低功耗模式
- 报告格式查文档

![image-20250720181718457](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201817517.png)

### HID主机服务

- HID使用类型：相当于功能
- 协议模式：一般为报告模式

![image-20250720181758203](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201817294.png)

### 报告描述符结构

#### 项目结构

![image-20250720183433321](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201834436.png)

#### 项目数据格式

##### 书籍

- HID协议 - USB_HID协议中文版.ppdf有详细的每一位的含义
- HID使用表 - hut1_22.pdf
- 报告描述符生成工具  - Dt.exe

![image-20250720183532001](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201835103.png)

## 代码分析

![image-20250720184129171](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507201841269.png)

### 数据包格式

#### 鼠标

![image-20250720214633998](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507202146101.png)

#### 键盘

![image-20250720214709467](C:\Users\a1874\AppData\Roaming\Typora\typora-user-images\image-20250720214709467.png)

#### 报告地图

```c
// HID Report Map characteristic value
// Keyboard report descriptor (using format for Boot interface descriptor)
static const uint8_t hidReportMap[] = {
    0x05, 0x01,  // Usage Page (Generic Desktop) 用途: 桌面通用 0000 0101 0000 0001 Global标签, 长度为1, 使用页面
    0x09, 0x02,  // Usage (Mouse)  用途 鼠标 0000 1001 0000 0010 标签, 大小为1, 用法页面
    0xA1, 0x01,  // Collection (Application)  1010 0001 0000 0001开集合 这是一个应用程序
    0x85, 0x01,  // Report Id (1) 1000 0101 报告ID, ID是01
    0x09, 0x01,  //   Usage (Pointer) 用途指针
    0xA1, 0x00,  //   Collection (Physical) 开集合-物理
    //第一个8位数据
    0x05, 0x09,  //     Usage Page (Buttons) 用途页, 按键
    0x19, 0x01,  //     Usage Minimum (01) - Button 1 最小值左键
    0x29, 0x03,  //     Usage Maximum (03) - Button 3 最大值 中键
    0x15, 0x00,  //     Logical Minimum (0) 逻辑最小值 按键抬起
    0x25, 0x01,  //     Logical Maximum (1) 逻辑最大值 按键按下
    0x75, 0x01,  //     Report Size (1) 报告的大小, 每一个占一位
    0x95, 0x03,  //     Report Count (3) 一共有三个报告: 3个按键
    0x81, 0x02,  //     Input (Data, Variable, Absolute) - Button states 数据输入, 可变, 独立, 绝对值
    0x75, 0x05,  //     Report Size (5) 报告大小 5个bit, 和前面的3bit为一个byte(这几位是无效的)
    0x95, 0x01,  //     Report Count (1) 报告数量 1
    0x81, 0x01,  //     Input (Constant) - Padding or Reserved bits 数据输入: 常量, 独立, 绝对值
    //3个字节, 鼠标的位移
    0x05, 0x01,  //     Usage Page (Generic Desktop)
    0x09, 0x30,  //     Usage (X)
    0x09, 0x31,  //     Usage (Y)
    0x09, 0x38,  //     Usage (Wheel)
    0x15, 0x81,  //     Logical Minimum (-127)
    0x25, 0x7F,  //     Logical Maximum (127)
    0x75, 0x08,  //     Report Size (8)
    0x95, 0x03,  //     Report Count (3)
    0x81, 0x06,  //     Input (Data, Variable, Relative) - X & Y coordinate 输入的数据相对值
    0xC0,        //   End Collection
    0xC0,        // End Collection
    //键盘
    0x05, 0x01,  // Usage Pg (Generic Desktop)
    0x09, 0x06,  // Usage (Keyboard)
    0xA1, 0x01,  // Collection: (Application)
    0x85, 0x02,  // Report Id (2)
    //
    0x05, 0x07,  //   Usage Pg (Key Codes)
    0x19, 0xE0,  //   Usage Min (224)
    0x29, 0xE7,  //   Usage Max (231)
    0x15, 0x00,  //   Log Min (0)
    0x25, 0x01,  //   Log Max (1)
    //
    //   Modifier byte 第一个byte
    0x75, 0x01,  //   Report Size (1)
    0x95, 0x08,  //   Report Count (8)
    0x81, 0x02,  //   Input: (Data, Variable, Absolute)
    //
    //   Reserved byte 保留的那一byte
    0x95, 0x01,  //   Report Count (1)
    0x75, 0x08,  //   Report Size (8)
    0x81, 0x01,  //   Input: (Constant)
    //
    //   LED report 键盘上面的led
    0x95, 0x05,  //   Report Count (5)
    0x75, 0x01,  //   Report Size (1)
    0x05, 0x08,  //   Usage Pg (LEDs)
    0x19, 0x01,  //   Usage Min (1)
    0x29, 0x05,  //   Usage Max (5)
    0x91, 0x02,  //   Output: (Data, Variable, Absolute)
    //
    //   LED report padding
    0x95, 0x01,  //   Report Count (1)
    0x75, 0x03,  //   Report Size (3)
    0x91, 0x01,  //   Output: (Constant)
    //
    //   Key arrays (6 bytes) 键值
    0x95, 0x06,  //   Report Count (6)
    0x75, 0x08,  //   Report Size (8)
    0x15, 0x00,  //   Log Min (0)
    0x25, 0x65,  //   Log Max (101)
    0x05, 0x07,  //   Usage Pg (Key Codes)
    0x19, 0x00,  //   Usage Min (0)
    0x29, 0x65,  //   Usage Max (101)
    0x81, 0x00,  //   Input: (Data, Array)
    //
    0xC0,        // End Collection
```

### 初始化

```c
void app_main(void)
{
    esp_err_t ret;

    // Initialize NVS.
    ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );

    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));

    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    esp_bt_controller_init(&bt_cfg);
    esp_bt_controller_enable(ESP_BT_MODE_BLE);
    esp_bluedroid_init();
    esp_bluedroid_enable();
    //HID初始化
    esp_hidd_profile_init();

    //注册GAP回调和HID回调
    esp_ble_gap_register_callback(gap_event_handler);
    esp_hidd_register_callbacks(hidd_event_callback);

    /* set the security iocap & auth_req & key size & init key response key parameters to the stack*/
    esp_ble_auth_req_t auth_req = ESP_LE_AUTH_BOND;     //仅绑定
    esp_ble_io_cap_t iocap = ESP_IO_CAP_NONE;           //无IO能力
    uint8_t key_size = 16;      //the key size should be 7~16 bytes
    //发起者密钥，给对方发送LTK和IRK
    uint8_t init_key = ESP_BLE_ENC_KEY_MASK | ESP_BLE_ID_KEY_MASK;

    //响应者密钥，接收LTK和IRK
    uint8_t rsp_key = ESP_BLE_ENC_KEY_MASK | ESP_BLE_ID_KEY_MASK;
    esp_ble_gap_set_security_param(ESP_BLE_SM_AUTHEN_REQ_MODE, &auth_req, sizeof(uint8_t));
    esp_ble_gap_set_security_param(ESP_BLE_SM_IOCAP_MODE, &iocap, sizeof(uint8_t));
    esp_ble_gap_set_security_param(ESP_BLE_SM_MAX_KEY_SIZE, &key_size, sizeof(uint8_t));
    /* If your BLE device act as a Slave, the init_key means you hope which types of key of the master should distribute to you,
    and the response key means which key you can distribute to the Master;
    If your BLE device act as a master, the response key means you hope which types of key of the slave should distribute to you,
    and the init key means which key you can distribute to the slave. */
    esp_ble_gap_set_security_param(ESP_BLE_SM_SET_INIT_KEY, &init_key, sizeof(uint8_t));
    esp_ble_gap_set_security_param(ESP_BLE_SM_SET_RSP_KEY, &rsp_key, sizeof(uint8_t));

    xTaskCreate(&hid_demo_task, "hid_task", 2048, NULL, 5, NULL);
}
```

### gatts回调

```c
//gatts回调函数
////esp_hidd_register_callbacks->hidd_register_cb->esp_ble_gatts_register_callback(gatts_event_handler)->gatts_event_handler
//-> heart_rate_profile_tab[PROFILE_APP_IDX]..gatts_cb = esp_hidd_prf_cb_hdl
void esp_hidd_prf_cb_hdl(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if,
									esp_ble_gatts_cb_param_t *param)
{
    switch(event) {
        //gatt注册app
        case ESP_GATTS_REG_EVT: {
            //设置外观
            esp_ble_gap_config_local_icon (ESP_BLE_APPEARANCE_GENERIC_HID);
            esp_hidd_cb_param_t hidd_param;
            hidd_param.init_finish.state = param->reg.status;
            //HID APP 
            if(param->reg.app_id == HIDD_APP_ID) {
                hidd_le_env.gatt_if = gatts_if;
                if(hidd_le_env.hidd_cb != NULL) {
                    (hidd_le_env.hidd_cb)(ESP_HIDD_EVENT_REG_FINISH, &hidd_param);
                    //创建HID服务
                    hidd_le_create_service(hidd_le_env.gatt_if);
                }
            }
            //电池服务
            if(param->reg.app_id == BATTRAY_APP_ID) {
                hidd_param.init_finish.gatts_if = gatts_if;
                 if(hidd_le_env.hidd_cb != NULL) {
                    (hidd_le_env.hidd_cb)(ESP_BAT_EVENT_REG, &hidd_param);
                }

            }

            break;
        }
        case ESP_GATTS_CONF_EVT: {
            break;
        }
        case ESP_GATTS_CREATE_EVT:
            break;
        case ESP_GATTS_CONNECT_EVT: {
            esp_hidd_cb_param_t cb_param = {0};
			ESP_LOGI(HID_LE_PRF_TAG, "HID connection establish, conn_id = %x",param->connect.conn_id);
			memcpy(cb_param.connect.remote_bda, param->connect.remote_bda, sizeof(esp_bd_addr_t));
            cb_param.connect.conn_id = param->connect.conn_id;
            hidd_clcb_alloc(param->connect.conn_id, param->connect.remote_bda);
            esp_ble_set_encryption(param->connect.remote_bda, ESP_BLE_SEC_ENCRYPT_NO_MITM);
            if(hidd_le_env.hidd_cb != NULL) {
                (hidd_le_env.hidd_cb)(ESP_HIDD_EVENT_BLE_CONNECT, &cb_param);
            }
            break;
        }
        case ESP_GATTS_DISCONNECT_EVT: {
			 if(hidd_le_env.hidd_cb != NULL) {
                    (hidd_le_env.hidd_cb)(ESP_HIDD_EVENT_BLE_DISCONNECT, NULL);
             }
            hidd_clcb_dealloc(param->disconnect.conn_id);
            break;
        }
        case ESP_GATTS_CLOSE_EVT:
            break;
        case ESP_GATTS_WRITE_EVT: {
            esp_hidd_cb_param_t cb_param = {0};
            if (param->write.handle == hidd_le_env.hidd_inst.att_tbl[HIDD_LE_IDX_REPORT_LED_OUT_VAL]) {
                cb_param.led_write.conn_id = param->write.conn_id;
                cb_param.led_write.report_id = HID_RPT_ID_LED_OUT;
                cb_param.led_write.length = param->write.len;
                cb_param.led_write.data = param->write.value;
                (hidd_le_env.hidd_cb)(ESP_HIDD_EVENT_BLE_LED_REPORT_WRITE_EVT, &cb_param);
            }
#if (SUPPORT_REPORT_VENDOR == true)
            if (param->write.handle == hidd_le_env.hidd_inst.att_tbl[HIDD_LE_IDX_REPORT_VENDOR_OUT_VAL] &&
                hidd_le_env.hidd_cb != NULL) {
                cb_param.vendor_write.conn_id = param->write.conn_id;
                cb_param.vendor_write.report_id = HID_RPT_ID_VENDOR_OUT;
                cb_param.vendor_write.length = param->write.len;
                cb_param.vendor_write.data = param->write.value;
                (hidd_le_env.hidd_cb)(ESP_HIDD_EVENT_BLE_VENDOR_REPORT_WRITE_EVT, &cb_param);
            }
#endif
            break;
        }
        //创建属性表完成事件
        case ESP_GATTS_CREAT_ATTR_TAB_EVT: {
            //如果创建电池服务属性表成功
            if (param->add_attr_tab.num_handle == BAS_IDX_NB &&
                param->add_attr_tab.svc_uuid.uuid.uuid16 == ESP_GATT_UUID_BATTERY_SERVICE_SVC &&
                param->add_attr_tab.status == ESP_GATT_OK) {
                    //记录句柄
                incl_svc.start_hdl = param->add_attr_tab.handles[BAS_IDX_SVC];
                incl_svc.end_hdl = incl_svc.start_hdl + BAS_IDX_NB -1;
                ESP_LOGI(HID_LE_PRF_TAG, "%s(), start added the hid service to the stack database. incl_handle = %d",
                           __func__, incl_svc.start_hdl);
                //创建HID属性表
                esp_ble_gatts_create_attr_tab(hidd_le_gatt_db, gatts_if, HIDD_LE_IDX_NB, 0);
            }
            //如果HID属性表创建成功
            if (param->add_attr_tab.num_handle == HIDD_LE_IDX_NB &&
                param->add_attr_tab.status == ESP_GATT_OK) {
                //记录属性表句柄
                memcpy(hidd_le_env.hidd_inst.att_tbl, param->add_attr_tab.handles,
                            HIDD_LE_IDX_NB*sizeof(uint16_t));
                ESP_LOGI(HID_LE_PRF_TAG, "hid svc handle = %x",hidd_le_env.hidd_inst.att_tbl[HIDD_LE_IDX_SVC]);
                //创建报告ID映射表
                hid_add_id_tbl();
                //开启HID服务
		        esp_ble_gatts_start_service(hidd_le_env.hidd_inst.att_tbl[HIDD_LE_IDX_SVC]);
            } else {
                //开启电池服务
                esp_ble_gatts_start_service(param->add_attr_tab.handles[0]);
            }
            break;
         }

        default:
            break;
    }
}

```

## 实际使用

- 初始化蓝牙BLE和HID

- 初始化串口（用于输入，串口接收终端的信息，然后解析之后通过蓝牙HID发送到设备端，实现无线蓝牙控制）

  - 也可以使用其他的办法，比如把gpio当作按键，按下某个gpio就相当于按下了键盘上的某个键，或者使用ADC读取摇杆数据等等，串口只是一个读取终端的数据，然后解析键盘的数据的工具

  - ```c
    void uart_init(void)
    {
    	uart_config_t uart_config = {
    			.baud_rate = 115200,
    			.data_bits = UART_DATA_8_BITS,
    			.parity = UART_PARITY_DISABLE,
    			.stop_bits = UART_STOP_BITS_1,
    			.flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
    			.source_clk = UART_SCLK_APB,
    		};
        //Install UART driver, and get the queue.
        uart_driver_install(EX_UART_NUM, BUF_SIZE * 2, BUF_SIZE * 2, 20, &uart0_queue, 0);
        uart_param_config(EX_UART_NUM, &uart_config);
    
        //Set UART log level
        esp_log_level_set(TAG, ESP_LOG_INFO);
        //Set UART pins (using UART0 default pins ie no changes.)
        uart_set_pin(EX_UART_NUM, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    	
    	key_flag = xQueueCreate(1, sizeof(int));
    
    	xTaskCreate(uart_event_task, "uart_event_task", 2048*3, NULL, 12, NULL);
    }
    
    static void uart_event_task(void *pvParameters)
    {
        uart_event_t event;
        size_t buffered_size;
    
        uint8_t* dtmp = (uint8_t*) malloc(RD_BUF_SIZE);
        for(;;) {
            //Waiting for UART event.
            if(xQueueReceive(uart0_queue, (void * )&event, (TickType_t)portMAX_DELAY)) {
                bzero(dtmp, RD_BUF_SIZE);
                ESP_LOGI(TAG, "uart[%d] event:", EX_UART_NUM);
                switch(event.type) {
                    //Event of UART receving data
                    /*We'd better handler data event fast, there would be much more data events than
                    other types of events. If we take too much time on data event, the queue might
                    be full.*/
                    case UART_DATA:
                        ESP_LOGI(TAG, "[UART DATA]: %d", event.size);
                        uart_read_bytes(EX_UART_NUM, dtmp, event.size, portMAX_DELAY);
                        ESP_LOGI(TAG, "[DATA EVT]:");
                        //uart_write_bytes(EX_UART_NUM, (const char*) dtmp, event.size);
    					//解析串口数据
    					printf("len = %d,test 0x%08lX\r\n",event.size,*(uint32_t*)dtmp);
    					
    #ifdef	DUOMEITI					
    					if(event.size == 1)
    					{
    
    #ifdef	TSET_KEYBOARD					
    						//键盘测试
    						send_keyboard_value(dtmp);
    
    						
    #else 
    						//多媒体控制测试
    						send_duomeiti_value(dtmp);
    					
    #endif/*TSET_KEYBOARD*/
    					}
    					
    #ifdef	TSET_MOUSE	//上下左右键值是3个字节
    					
    					if(event.size == 3)
    					{
    						//鼠标测试
    						send_mouse_value(dtmp);
    					}
    #endif/*TSET_MOUSE*/
    
    					else
    						printf("input error\r\n");
    #endif/*DUOMEITI*/
    					
                        break;
                    //Event of HW FIFO overflow detected
                    case UART_FIFO_OVF:
                        ESP_LOGI(TAG, "hw fifo overflow");
                        // If fifo overflow happened, you should consider adding flow control for your application.
                        // The ISR has already reset the rx FIFO,
                        // As an example, we directly flush the rx buffer here in order to read more data.
                        uart_flush_input(EX_UART_NUM);
                        xQueueReset(uart0_queue);
                        break;
                    //Event of UART ring buffer full
                    case UART_BUFFER_FULL:
                        ESP_LOGI(TAG, "ring buffer full");
                        // If buffer full happened, you should consider encreasing your buffer size
                        // As an example, we directly flush the rx buffer here in order to read more data.
                        uart_flush_input(EX_UART_NUM);
                        xQueueReset(uart0_queue);
                        break;
                    //Event of UART RX break detected
                    case UART_BREAK:
                        ESP_LOGI(TAG, "uart rx break");
                        break;
                    //Event of UART parity check error
                    case UART_PARITY_ERR:
                        ESP_LOGI(TAG, "uart parity error");
                        break;
                    //Event of UART frame error
                    case UART_FRAME_ERR:
                        ESP_LOGI(TAG, "uart frame error");
                        break;
                    //UART_PATTERN_DET
                    case UART_PATTERN_DET:
                        uart_get_buffered_data_len(EX_UART_NUM, &buffered_size);
                        int pos = uart_pattern_pop_pos(EX_UART_NUM);
                        ESP_LOGI(TAG, "[UART PATTERN DETECTED] pos: %d, buffered size: %d", pos, buffered_size);
                        if (pos == -1) {
                            // There used to be a UART_PATTERN_DET event, but the pattern position queue is full so that it can not
                            // record the position. We should set a larger queue size.
                            // As an example, we directly flush the rx buffer here.
                            uart_flush_input(EX_UART_NUM);
                        } else {
                            uart_read_bytes(EX_UART_NUM, dtmp, pos, 100 / portTICK_PERIOD_MS);
                            uint8_t pat[PATTERN_CHR_NUM + 1];
                            memset(pat, 0, sizeof(pat));
                            uart_read_bytes(EX_UART_NUM, pat, PATTERN_CHR_NUM, 100 / portTICK_PERIOD_MS);
                            ESP_LOGI(TAG, "read data: %s", dtmp);
                            ESP_LOGI(TAG, "read pat : %s", pat);
                        }
                        break;
                    //Others
                    default:
                        ESP_LOGI(TAG, "uart event type: %d", event.type);
                        break;
                }
            }
        }
        free(dtmp);
        dtmp = NULL;
        vTaskDelete(NULL);
    }
    
    ```

  - 在esp_hidd_prf_api.h文件里面定义新的功能，声明函数

    - ```c
      #define DUOMEITI
      ```

  - 在hidd_le_prf_int.h文件中添加定义的报告ID

    - ```c
      #define HID_RPT_ID_DUOMEITI_IN  5 
      ```

  - hid_device_le_prf.c文件 添加报告地图，在hidReportMap报告地图的数组里添加多媒体控制的报告描述符

    - ```c
      #ifdef DUOMEITI 
          0x05, 0x0c,       // USAGE_PAGE (Consumer Devices) 5
          0x09, 0x01,       // Usage (Consumer Control) 6
          0xa1, 0x01,       // Collection (Application) 7
          0x85, 0x05,       //   Report Id (5) 8
          0x15, 0x00,       //   Logical minimum  (0) 9
          0x25, 0x01,       //   Logical maximum (1) 10
          0x75, 0x01,       //   Report Size (1) 11
          0x95, 0x01,       //   Report Count (1) 12
          0x09, 0xcd,       //   Usage (Play/Pause)    //播放/暂停13
          0x81, 0x06,       //   Input (Data,Var,Rel) 14
          0x09, 0x6f,       //   Usage (Display Brightness Increment)  //亮度增加15
          0x81, 0x06,       //   Input (Data,Var,Rel) 16
      
          0x09, 0x70,       //   Usage (Display Brightness Decrement)  //亮度降低17
          0x81, 0x06,       //   Input (Data,Var,Rel) 18
          0x09, 0xb5,       //   Usage (Scan Next Track)   //下一曲19
          0x81, 0x06,       //   Input (Data,Var,Rel) 20
       
       
          0x09, 0xb6,       //   Usage (Scan Previous Track)   //上一曲23
          0x81, 0x06,       //   Input (Data,Var,Rel) 24
          0x09, 0xe9,       //   Usage (Volume Up)    //音量增大25
          0x81, 0x06,       //   Input (Data,Var,Rel) 26
          0x09, 0xea,       //   Usage (Volume Down)    //音量减小27
          0x81, 0x06,       //   Input (Data,Var,Rel) 28
          0x95, 0x01,    //   Report Count (1) 29
          0x75, 0x08,     //   Report Size (1) 30
          0x81, 0x01,     //   Input: (Constant)   //保留31
          0xc0              // End Collection 32
      #endif
      
      ```

  - 定义报告类型和ID以及在HID属性表中添加功能属性，在服务索引中添加新的下标

    - ```c
       #ifdef DUOMEITI
          HIDD_LE_IDX_REPORT_DUOMEITI_IN_CHAR, 
          HIDD_LE_IDX_REPORT_DUOMEITI_IN_VAL, 
          HIDD_LE_IDX_REPORT_DUOMEITI_IN_CCC, 
          HIDD_LE_IDX_REPORT_DUOMEITI_IN_REP_REF, 
       #endif 
      ```

    - ```c
       //多媒体控制的报告ID和类型 映射表参数2
       #ifdef DUOMEITI 
       static uint8_t hidReportRefDmtIn[HID_REPORT_REF_LEN] = 
                   { HID_RPT_ID_DUOMEITI_IN, HID_REPORT_TYPE_INPUT }; 
       #endif
      
      
      #ifdef DUOMEITI 
       
       // 多媒体控制特征声明
      
          [HIDD_LE_IDX_REPORT_DUOMEITI_IN_CHAR]   = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid,
                                                      ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE, 
                                                      CHAR_DECLARATION_SIZE,
                                                      (uint8_t *)&char_prop_read_notify}},
       
          // 特征值
          [HIDD_LE_IDX_REPORT_DUOMEITI_IN_VAL]    = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&hid_report_uuid,
                                                      ESP_GATT_PERM_READ, 
                                                      HIDD_LE_REPORT_MAX_LEN, 
                                                      0, 
                                                      NULL}}, 
          // 客户端特征配置
          [HIDD_LE_IDX_REPORT_DUOMEITI_IN_CCC]     = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid,(
                                                      ESP_GATT_PERM_READ |ESP_GATT_PERM_WRITE_ENCRYPTED),
                                                      sizeof(uint16_t), 
                                                      0,NULL}}, 
           // 报告参考
          [HIDD_LE_IDX_REPORT_DUOMEITI_IN_REP_REF] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&hid_report_ref_descr_uuid,
                                                      ESP_GATT_PERM_READ,
                                                      sizeof(hidReportRefDmtIn),
                                                      sizeof(hidReportRefDmtIn),
                                                      hidReportRefDmtIn}},   
          
       #endif 
      
      ```

  - 添加报告映射hid_add_id_tbl函数

    - ```c
      //多媒体控制映射表封装
      #ifdef	DUOMEITI
      	  hid_rpt_map[8].id = hidReportRefDmtIn[0];
            hid_rpt_map[8].type = hidReportRefDmtIn[1];
            hid_rpt_map[8].handle = hidd_le_env.hidd_inst.att_tbl[HIDD_LE_IDX_REPORT_DUOMEITI_IN_VAL];
            hid_rpt_map[8].cccdHandle = hidd_le_env.hidd_inst.att_tbl[HIDD_LE_IDX_REPORT_DUOMEITI_IN_CCC];
            hid_rpt_map[8].mode = HID_PROTOCOL_MODE_REPORT;
      	  printf("duomeiti headle =	%d,Report ID = %d,type = %d\r\n",hid_rpt_map[8].handle,hid_rpt_map[8].id,hid_rpt_map[8].type);
      #endif
      ```

  - 最后对键值进行一些处理

    - 比如ASCII转HID键盘值

    - 丰富键值

      - ```c
        #define HID_KEY_NONE                      0x00
        #define HID_KEY_A                         0x04
        #define HID_KEY_B                         0x05
        #define HID_KEY_C                         0x06
        #define HID_KEY_D                         0x07
        #define HID_KEY_E                         0x08
        #define HID_KEY_F                         0x09
        #define HID_KEY_G                         0x0A
        #define HID_KEY_H                         0x0B
        #define HID_KEY_I                         0x0C
        #define HID_KEY_J                         0x0D
        #define HID_KEY_K                         0x0E
        #define HID_KEY_L                         0x0F
        #define HID_KEY_M                         0x10
        #define HID_KEY_N                         0x11
        #define HID_KEY_O                         0x12
        #define HID_KEY_P                         0x13
        #define HID_KEY_Q                         0x14
        #define HID_KEY_R                         0x15
        #define HID_KEY_S                         0x16
        #define HID_KEY_T                         0x17
        #define HID_KEY_U                         0x18
        #define HID_KEY_V                         0x19
        #define HID_KEY_W                         0x1A
        #define HID_KEY_X                         0x1B
        #define HID_KEY_Y                         0x1C
        #define HID_KEY_Z                         0x1D
        #define HID_KEY_1                         0x1E
        #define HID_KEY_2                         0x1F
        #define HID_KEY_3                         0x20
        #define HID_KEY_4                         0x21
        #define HID_KEY_5                         0x22
        #define HID_KEY_6                         0x23
        #define HID_KEY_7                         0x24
        #define HID_KEY_8                         0x25
        #define HID_KEY_9                         0x26
        #define HID_KEY_0                         0x27
        #define HID_KEY_ENTER                     0x28
        #define HID_KEY_ESCAPE                    0x29
        #define HID_KEY_BACKSPACE                 0x2A
        #define HID_KEY_TAB                       0x2B
        #define HID_KEY_SPACE                     0x2C
        #define HID_KEY_MINUS                     0x2D
        #define HID_KEY_EQUAL                     0x2E
        #define HID_KEY_BRACKET_LEFT              0x2F
        #define HID_KEY_BRACKET_RIGHT             0x30
        #define HID_KEY_BACKSLASH                 0x31
        #define HID_KEY_EUROPE_1                  0x32
        #define HID_KEY_SEMICOLON                 0x33
        #define HID_KEY_APOSTROPHE                0x34
        #define HID_KEY_GRAVE                     0x35
        #define HID_KEY_COMMA                     0x36
        #define HID_KEY_PERIOD                    0x37
        #define HID_KEY_SLASH                     0x38
        #define HID_KEY_CAPS_LOCK                 0x39
        #define HID_KEY_F1                        0x3A
        #define HID_KEY_F2                        0x3B
        #define HID_KEY_F3                        0x3C
        #define HID_KEY_F4                        0x3D
        #define HID_KEY_F5                        0x3E
        #define HID_KEY_F6                        0x3F
        #define HID_KEY_F7                        0x40
        #define HID_KEY_F8                        0x41
        #define HID_KEY_F9                        0x42
        #define HID_KEY_F10                       0x43
        #define HID_KEY_F11                       0x44
        #define HID_KEY_F12                       0x45
        #define HID_KEY_PRINT_SCREEN              0x46
        #define HID_KEY_SCROLL_LOCK               0x47
        #define HID_KEY_PAUSE                     0x48
        #define HID_KEY_INSERT                    0x49
        #define HID_KEY_HOME                      0x4A
        #define HID_KEY_PAGE_UP                   0x4B
        #define HID_KEY_DELETE                    0x4C
        #define HID_KEY_END                       0x4D
        #define HID_KEY_PAGE_DOWN                 0x4E
        #define HID_KEY_ARROW_RIGHT               0x4F
        #define HID_KEY_ARROW_LEFT                0x50
        #define HID_KEY_ARROW_DOWN                0x51
        #define HID_KEY_ARROW_UP                  0x52
        #define HID_KEY_NUM_LOCK                  0x53
        #define HID_KEY_KEYPAD_DIVIDE             0x54
        #define HID_KEY_KEYPAD_MULTIPLY           0x55
        #define HID_KEY_KEYPAD_SUBTRACT           0x56
        #define HID_KEY_KEYPAD_ADD                0x57
        #define HID_KEY_KEYPAD_ENTER              0x58
        #define HID_KEY_KEYPAD_1                  0x59
        #define HID_KEY_KEYPAD_2                  0x5A
        #define HID_KEY_KEYPAD_3                  0x5B
        #define HID_KEY_KEYPAD_4                  0x5C
        #define HID_KEY_KEYPAD_5                  0x5D
        #define HID_KEY_KEYPAD_6                  0x5E
        #define HID_KEY_KEYPAD_7                  0x5F
        #define HID_KEY_KEYPAD_8                  0x60
        #define HID_KEY_KEYPAD_9                  0x61
        #define HID_KEY_KEYPAD_0                  0x62
        #define HID_KEY_KEYPAD_DECIMAL            0x63
        #define HID_KEY_EUROPE_2                  0x64
        #define HID_KEY_APPLICATION               0x65
        #define HID_KEY_POWER                     0x66
        #define HID_KEY_KEYPAD_EQUAL              0x67
        #define HID_KEY_F13                       0x68
        #define HID_KEY_F14                       0x69
        #define HID_KEY_F15                       0x6A
        #define HID_KEY_F16                       0x6B
        #define HID_KEY_F17                       0x6C
        #define HID_KEY_F18                       0x6D
        #define HID_KEY_F19                       0x6E
        #define HID_KEY_F20                       0x6F
        #define HID_KEY_F21                       0x70
        #define HID_KEY_F22                       0x71
        #define HID_KEY_F23                       0x72
        #define HID_KEY_F24                       0x73
        #define HID_KEY_EXECUTE                   0x74
        #define HID_KEY_HELP                      0x75
        #define HID_KEY_MENU                      0x76
        #define HID_KEY_SELECT                    0x77
        #define HID_KEY_STOP                      0x78
        #define HID_KEY_AGAIN                     0x79
        #define HID_KEY_UNDO                      0x7A
        #define HID_KEY_CUT                       0x7B
        #define HID_KEY_COPY                      0x7C
        #define HID_KEY_PASTE                     0x7D
        #define HID_KEY_FIND                      0x7E
        #define HID_KEY_MUTE                      0x7F
        #define HID_KEY_VOLUME_UP                 0x80
        #define HID_KEY_VOLUME_DOWN               0x81
        #define HID_KEY_LOCKING_CAPS_LOCK         0x82
        #define HID_KEY_LOCKING_NUM_LOCK          0x83
        #define HID_KEY_LOCKING_SCROLL_LOCK       0x84
        #define HID_KEY_KEYPAD_COMMA              0x85
        #define HID_KEY_KEYPAD_EQUAL_SIGN         0x86
        #define HID_KEY_KANJI1                    0x87
        #define HID_KEY_KANJI2                    0x88
        #define HID_KEY_KANJI3                    0x89
        #define HID_KEY_KANJI4                    0x8A
        #define HID_KEY_KANJI5                    0x8B
        #define HID_KEY_KANJI6                    0x8C
        #define HID_KEY_KANJI7                    0x8D
        #define HID_KEY_KANJI8                    0x8E
        #define HID_KEY_KANJI9                    0x8F
        #define HID_KEY_LANG1                     0x90
        #define HID_KEY_LANG2                     0x91
        #define HID_KEY_LANG3                     0x92
        #define HID_KEY_LANG4                     0x93
        #define HID_KEY_LANG5                     0x94
        #define HID_KEY_LANG6                     0x95
        #define HID_KEY_LANG7                     0x96
        #define HID_KEY_LANG8                     0x97
        #define HID_KEY_LANG9                     0x98
        #define HID_KEY_ALTERNATE_ERASE           0x99
        #define HID_KEY_SYSREQ_ATTENTION          0x9A
        #define HID_KEY_CANCEL                    0x9B
        #define HID_KEY_CLEAR                     0x9C
        #define HID_KEY_PRIOR                     0x9D
        #define HID_KEY_RETURN                    0x9E
        #define HID_KEY_SEPARATOR                 0x9F
        #define HID_KEY_OUT                       0xA0
        #define HID_KEY_OPER                      0xA1
        #define HID_KEY_CLEAR_AGAIN               0xA2
        #define HID_KEY_CRSEL_PROPS               0xA3
        #define HID_KEY_EXSEL                     0xA4
        // RESERVED					                      0xA5-DF
        #define HID_KEY_CONTROL_LEFT              0xE0
        #define HID_KEY_SHIFT_LEFT                0xE1
        #define HID_KEY_ALT_LEFT                  0xE2
        #define HID_KEY_GUI_LEFT                  0xE3
        #define HID_KEY_CONTROL_RIGHT             0xE4
        #define HID_KEY_SHIFT_RIGHT               0xE5
        #define HID_KEY_ALT_RIGHT                 0xE6
        #define HID_KEY_GUI_RIGHT                 0xE7
        
        
        typedef uint8_t keyboard_cmd_t;
        
        #define HID_MOUSE_LEFT       253
        #define HID_MOUSE_MIDDLE     254
        #define HID_MOUSE_RIGHT      255
        typedef uint8_t mouse_cmd_t;
        
        /****************************************************************/
        
        typedef uint8_t keyboard_cmd_t;
        
        #define HID_MOUSE_LEFT       253
        #define HID_MOUSE_MIDDLE     254
        #define HID_MOUSE_RIGHT      255
        typedef uint8_t mouse_cmd_t;
        ```

  - 编写hid_demo任务

    - key_flag队列在串口任务里面发送，是由串口解析出来的按键数据

    - ```c
      void hid_demo_task(void *pvParameters)
      {
      	
      	uint8_t key = 0;
      	uint8_t key_arr[]= {0,0};
      	uint32_t gpio_num = 0;
      
          vTaskDelay(1000 / portTICK_PERIOD_MS);
          while(1)
      	{
              
              if (sec_conn) 
      		{
                  
      
      #ifdef	DUOMEITI	
      			if(xQueueReceive(key_flag, &gpio_num, portMAX_DELAY))
      			{
      				ESP_LOGI(HID_DEMO_TAG, "Send the key");
      #ifdef	TSET_KEYBOARD
      				//键盘触发
      				const uint8_t * key_p = ascii_to_key(gpio_num);
      				if(key_p)
      				{
      					memcpy(key_arr,key_p,2);
      					
      					esp_hidd_send_keyboard_value(hid_conn_id, 0,key_arr, sizeof(key_arr));
      					esp_hidd_send_keyboard_value(hid_conn_id, 0,&key, 1);
      				}
                  
      			
      #elif	TSET_MOUSE	//鼠标
      			
      				//电脑键盘上下左右键输入值			
      				#define KEY_UP                  0x415B1B		//上
      				#define KEY_DOWN                0x425B1B		//下
      				#define KEY_LEFT                0x445B1B		//左
      				#define KEY_RIGHT               0x435B1B		//右
      				
      				uint8_t mouse_button = 0;
      				char x = 0,y = 0;
      				
      				switch(gpio_num)
      				{
      					case KEY_RIGHT:	x = 5;	break;		//右正
      					case KEY_LEFT:	x = -5;	break;		//左负
      					case KEY_UP:	y = -5;	break;		//上负
      					case KEY_DOWN:	y = 5;	break;		//下正
      					
      					default:	;
      				
      				}
      				esp_hidd_send_mouse_value(hid_conn_id,mouse_button,x,y);
      				/*
      				//左键按下
      				esp_hidd_send_mouse_value(hid_conn_id,1,0,0);
      				//全部松开
      				esp_hidd_send_mouse_value(hid_conn_id,0,0,0);
      				
      				*/
      				printf("X = %d,Y = %d\r\n",(int)x,(int)y);
      
      			
      #else
      				
      				
      				//多媒体控制				
      				if(gpio_num >= 0 && gpio_num < 16)
      				{
      					//0.暂停和播放键
      					//1.亮度增大    2.亮度减弱
      					//3.下一曲      4.上一曲
      					//5.音量增大    6.音量减小
      					//7.保留
      					esp_hidd_send_duomeiti_value(hid_conn_id,(uint16_t )(1 << gpio_num));
      				}				
      			
      #endif
      
      			vTaskDelay(20 / portTICK_PERIOD_MS);
      			
      		    }	
      #endif
      	    }			
      
          }
      }
      
      ```

    - ```c
      void send_keyboard_value(uint8_t *value)
      {
      	uint32_t tmp = *value;
      	xQueueSend(key_flag,&tmp,10/portTICK_PERIOD_MS);
      
      }
      
      void send_mouse_value(uint8_t *value)
      {
      	uint32_t tmp = *(uint32_t *)value;
      	tmp &= 0xffffff;		//只占3个字节
      	xQueueSend(key_flag,&tmp,10/portTICK_PERIOD_MS);
      }
      
      void send_duomeiti_value(uint8_t *value)
      {
      	uint32_t tmp = 0xFFFFFFFF;
      	switch(*value)
      	{
      		case '0':	tmp = 0;	break;
      		case '1':	tmp = 1;	break;
      		case '2':	tmp = 2;	break;
      		case '3':	tmp = 3;	break;
      		case '4':	tmp = 4;	break;
      		case '5':	tmp = 5;	break;
      		case '6':	tmp = 6;	break;
      		case '7':	tmp = 7;	break;
      		case '8':	tmp = 8;	break;
      		case '9':	tmp = 9;	break;
      		case 'a':	tmp = 10;	break;
      		case 'b':	tmp = 11;	break;
      		case 'c':	tmp = 12;	break;
      		case 'd':	tmp = 13;	break;
      		case 'e':	tmp = 14;	break;
      		case 'f':	tmp = 15;	break;
      		
      		default :		;
      			
      	}
      	if(tmp != 0xFFFFFFFF)
      	{
      		printf("tmp = %lu\r\n",tmp);
      		xQueueSend(key_flag,&tmp,10/portTICK_PERIOD_MS);
      		
      	}
      }
      ```

      
