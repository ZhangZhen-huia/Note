# 简介

- I2S（Inter-IC Sound，集成电路内置音频总线）是一种同步串行通信协议，通常用于在两个数字音频设备之间传输音频数据
- ESP32 包含 2 个 I2S 外设
- I2S包含多个模式，标准模式（双声道模式）、PDM模式（脉冲密度调制模式）、LCD/摄像头模式、ADC/DAC模式

> 标准 模式下的 I2S 总线包含以下几条线路
>
> - **MCLK**：主时钟频率，BCLK 由其产生。MCLK 信号通常作为参考时钟，用于同步 I2S 主机和从机之间的 BCLK 和 WS
> - **BCLK**：位时钟频率，一个 BCLK 时钟周期代表数据管脚上的一个数据位，通过 [`i2s_std_slot_config_t::slot_bit_width`]配置的通道位宽即为一个声道中的 BCLK 时钟周期数量，因此一个声道中可以有 8/16/24/32 个 BCLK 时钟周期
> - **WS**：字（声道）选择线。（片选线）通常用于识别声道（除 PDM 模式外）。
> - **DIN/DOUT**：串行数据输入/输出线。如果 DIN 和 DOUT 被配置到相同的 GPIO，数据将在内部回环。
>
> PDM 通信模式下的 I2S 总线包含以下几条线路：
>
> - **CLK**：PDM 时钟线。
> - **DIN/DOUT**：串行数据输入/输出线。

每一个I2S控制器都可以用作系统从机或者主机，接收器或发射器，支持DMA

## I2S的资源

- `平台级资源`：当前芯片中所有 I2S 控制器的资源。
- `控制器级资源`：一个 I2S 控制器的资源。
- `通道级资源`：一个 I2S 控制器 TX 或 RX 通道的资源

## I2S状态

```c
registered（已注册）、 ready（准备就绪）和 running（运行中）
```

> ![image-20250704150659423](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202507041506480.png)

# 驱动

- `i2s.h`：提供原有 I2S API（用于使用原有驱动的应用）。
- `i2s_std.h`：提供标准通信模式的 API（用于使用标准模式的新驱动程序的应用）。
- `i2s_pdm.h`：提供 PDM 通信模式的 API（用于使用 PDM 模式的新驱动程序的应用）

新旧驱动不共存

## 结构体

### i2s_chan_config_t - I2S通道配置

```c
i2s_port_t id//端口号，I2S_NUM_AUTO表示自动选择端口
i2s_role_t role//I2S作为Master或者Slave
    
    
uint32_t dma_desc_num//DMA 缓冲区数量（建议 ≥2，典型值 4）
uint32_t dma_frame_num//每帧 DMA 缓冲区大小（字节，典型值 1024）
/*
DMA 缓冲区大小：
dma_frame_num × dma_desc_num 决定了 DMA 总缓冲区大小
*/
bool auto_clear//是否在删除通道时自动清理 DMA 缓冲区
bool auto_clear_after_cb//是否在发送回调之后自动清理 DMA TX缓冲区
bool auto_clear_before_cb//是否在发送回调之前自动清理 DMA TX缓冲区
bool allow_pd// 是否允许PowerDown来减少功耗，但是会增大内存损耗
int intr_priority//中断优先级
```

#### 快捷配置宏

```c
#define I2S_CHANNEL_DEFAULT_CONFIG(i2s_num, i2s_role) { \
    .id = i2s_num, \
    .role = i2s_role, \
    .dma_desc_num = 6, \
    .dma_frame_num = 240, \
    .auto_clear_after_cb = false, \
    .auto_clear_before_cb = false, \
    .allow_pd = false, \
    .intr_priority = 0, \
}
```

### i2s_std_config_t - I2S标准 模式配置

```c
i2s_std_clk_config_t clk_cfg//Standard mode clock configuration, can be generated by  I2S_STD_CLK_DEFAULT_CONFIG
    
i2s_std_slot_config_t slot_cfg//Standard mode slot configuration, can be generated by macros I2S_STD_[mode]_SLOT_DEFAULT_CONFIG, [mode] can be replaced with PHILIPS/MSB/PCM

i2s_std_gpio_config_t gpio_cfg//Standard mode GPIO configuration, specified by user
```

配置完成后可以调用下面的函数来初始化

```c
i2s_channel_init_std_mode
```



## 通道相关函数

### 通道句柄

```c
typedef struct i2s_channel_obj_t *i2s_chan_handle_t
```

### 开启通道

```c
esp_err_t i2s_channel_enable(i2s_chan_handle_t handle)
```

### 分配和删除通道

```c
esp_err_t i2s_new_channel(const i2s_chan_config_t *chan_cfg, i2s_chan_handle_t *ret_tx_handle, i2s_chan_handle_t *ret_rx_handle)
//I2S控制结构体，用于发送的I2S通道句柄，用于接收的I2S通道句柄
   
esp_err_t i2s_del_channel(i2s_chan_handle_t handle)
//I2S通道句柄
```

### 失能通道

```c
esp_err_t i2s_channel_disable(i2s_chan_handle_t handle)
    //使得通道从运行态变为就绪态
```

## 数据传输

I2S的数据传输由DMA实现

### 写入

```c
esp_err_t i2s_channel_write(i2s_chan_handle_t handle, const void *src, size_t size, size_t *bytes_written, uint32_t timeout_ms)
```

### 读取

```c
esp_err_t i2s_channel_read(i2s_chan_handle_t handle, void *dest, size_t size, size_t *bytes_read, uint32_t timeout_ms)
```

### 实现非阻塞（注册回调函数）

```c
esp_err_t i2s_channel_register_event_callback(i2s_chan_handle_t handle, const i2s_event_callbacks_t *callbacks, void *user_data)
```

## 初始化模式

```c
esp_err_t i2s_channel_init_std_mode(i2s_chan_handle_t handle, const i2s_std_config_t *std_cfg)
    
i2s_channel_init_pdm_rx_mode()
    
i2s_channel_init_pdm_tx_mode()
    
i2s_channel_init_tdm_mode()
```

若是初始化之后需要更改配置，就要先失能通道，再调用 reconfig 函数，如

```c
esp_err_t i2s_channel_reconfig_std_slot(i2s_chan_handle_t handle, const i2s_std_slot_config_t *slot_cfg)
```

# 实例——播放音频

该板子需要配合一个pca9557扩展io芯片来实现音乐的播放与暂停

## i2s_driver_init

```c
// 初始化I2S外设
static esp_err_t i2s_driver_init(void)
{
    /* 配置i2s发送通道 */
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM, I2S_ROLE_MASTER);
    chan_cfg.auto_clear = true; // Auto clear the legacy data in the DMA buffer
    ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_handle, NULL));
    /* 初始化i2s为std模式 并打开i2s发送通道 */
    i2s_std_config_t std_cfg = {
        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(EXAMPLE_SAMPLE_RATE),
        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_MCK_IO,
            .bclk = I2S_BCK_IO,
            .ws = I2S_WS_IO,
            .dout = I2S_DO_IO,
            .din = I2S_DI_IO,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };
    std_cfg.clk_cfg.mclk_multiple = EXAMPLE_MCLK_MULTIPLE;

    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_handle, &std_cfg));
    ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));

    return ESP_OK;
}
```

## es8311初始化

```c
typedef struct {
    i2c_port_t port;
    uint16_t dev_addr;
} es8311_dev_t;
```

```c
es8311_handle_t es8311_create(const i2c_port_t port, const uint16_t dev_addr)
{
    es8311_dev_t *sensor = (es8311_dev_t *) calloc(1, sizeof(es8311_dev_t));
    sensor->port = port;
    sensor->dev_addr = dev_addr;
    return (es8311_handle_t) sensor;
}
```

```c
static esp_err_t es8311_codec_init(void)
{
    /* Initialize I2C peripheral */
#if !defined(CONFIG_EXAMPLE_BSP)
    //初始化I2C驱动
    const i2c_config_t es_i2c_cfg = {
        .sda_io_num = I2C_SDA_IO,
        .scl_io_num = I2C_SCL_IO,
        .mode = I2C_MODE_MASTER,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = 100000,
    };
    ESP_RETURN_ON_ERROR(i2c_param_config(I2C_NUM, &es_i2c_cfg), TAG, "config i2c failed");
    ESP_RETURN_ON_ERROR(i2c_driver_install(I2C_NUM, I2C_MODE_MASTER,  0, 0, 0), TAG, "install i2c driver failed");
#else
    ESP_ERROR_CHECK(bsp_i2c_init());
#endif
	//初始化esc8311
    /* Initialize es8311 codec */
    es8311_handle_t es_handle = es8311_create(I2C_NUM, ES8311_ADDRRES_0);
    ESP_RETURN_ON_FALSE(es_handle, ESP_FAIL, TAG, "es8311 create failed");
    const es8311_clock_config_t es_clk = {
        .mclk_inverted = false,
        .sclk_inverted = false,
        .mclk_from_mclk_pin = true,
        .mclk_frequency = EXAMPLE_MCLK_FREQ_HZ,
        .sample_frequency = EXAMPLE_SAMPLE_RATE
    };

    ESP_ERROR_CHECK(es8311_init(es_handle, &es_clk, ES8311_RESOLUTION_16, ES8311_RESOLUTION_16));
    ESP_RETURN_ON_ERROR(es8311_sample_frequency_config(es_handle, EXAMPLE_SAMPLE_RATE * EXAMPLE_MCLK_MULTIPLE, EXAMPLE_SAMPLE_RATE), TAG, "set es8311 sample frequency failed");//设置采样频率
    ESP_RETURN_ON_ERROR(es8311_voice_volume_set(es_handle, EXAMPLE_VOICE_VOLUME, NULL), TAG, "set es8311 volume failed");//设置声音大小
    ESP_RETURN_ON_ERROR(es8311_microphone_config(es_handle, false), TAG, "set es8311 microphone failed");//设置麦克风false: 模拟麦克风 true数字麦克风
    
    //回声增益
#if CONFIG_EXAMPLE_MODE_ECHO
    ESP_RETURN_ON_ERROR(es8311_microphone_gain_set(es_handle, EXAMPLE_MIC_GAIN), TAG, "set es8311 microphone gain failed");//配置麦克风的增益
#endif
    return ESP_OK;
}
```

## music任务

```c
extern const uint8_t music_pcm_start[] asm("_binary_canon_pcm_start");
extern const uint8_t music_pcm_end[]   asm("_binary_canon_pcm_end");
```



```c
static void i2s_music(void *args)
{
    esp_err_t ret = ESP_OK;
    size_t bytes_write = 0;
    uint8_t *data_ptr = (uint8_t *)music_pcm_start;//音乐的开始

    /* (Optional) Disable TX channel and preload the data before enabling the TX channel,
     * so that the valid data can be transmitted immediately */
    ESP_ERROR_CHECK(i2s_channel_disable(tx_handle));  //失能输出通道
    ESP_ERROR_CHECK(i2s_channel_preload_data(tx_handle, data_ptr, music_pcm_end - data_ptr, &bytes_write));//预加载输出的数据
    data_ptr += bytes_write;  // Move forward the data pointer

    /* 开启输出通道 */
    ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));
    while (1) {
        /* 输出音乐，把canon.pcm文件数据输出 */
        ret = i2s_channel_write(tx_handle, data_ptr, music_pcm_end - data_ptr, &bytes_write, portMAX_DELAY);
        
        if (ret != ESP_OK) {
            /* Since we set timeout to 'portMAX_DELAY' in 'i2s_channel_write'
               so you won't reach here unless you set other timeout value,
               if timeout detected, it means write operation failed. */
            ESP_LOGE(TAG, "[music] i2s write failed, %s", err_reason[ret == ESP_ERR_TIMEOUT]);
            abort();
        }
        if (bytes_write > 0) {
            ESP_LOGI(TAG, "[music] i2s music played, %d bytes are written.", bytes_write);
        } else {
            ESP_LOGE(TAG, "[music] i2s music play failed.");
            abort();
        }
        data_ptr = (uint8_t *)music_pcm_start;
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
    vTaskDelete(NULL);
}
```

## PCA9557扩展芯片

```c
/***********************************************************/
/***************    IO扩展芯片 ↓   *************************/

// 读取PCA9557寄存器的值
esp_err_t pca9557_register_read(uint8_t reg_addr, uint8_t *data, size_t len)
{
    return i2c_master_write_read_device(BSP_I2C_NUM, PCA9557_SENSOR_ADDR,  &reg_addr, 1, data, len, 1000 / portTICK_PERIOD_MS);
}

// 给PCA9557的寄存器写值
esp_err_t pca9557_register_write_byte(uint8_t reg_addr, uint8_t data)
{
    uint8_t write_buf[2] = {reg_addr, data};

    return i2c_master_write_to_device(BSP_I2C_NUM, PCA9557_SENSOR_ADDR, write_buf, sizeof(write_buf), 1000 / portTICK_PERIOD_MS);
}

// 初始化PCA9557 IO扩展芯片
void pca9557_init(void)
{
    // 写入控制引脚默认值 DVP_PWDN=1  PA_EN = 0  LCD_CS = 1
    pca9557_register_write_byte(PCA9557_OUTPUT_PORT, 0x05);  
    // 把PCA9557芯片的IO1 IO1 IO2设置为输出 其它引脚保持默认的输入
    pca9557_register_write_byte(PCA9557_CONFIGURATION_PORT, 0xf8); 
}

// 设置PCA9557芯片的某个IO引脚输出高低电平
esp_err_t pca9557_set_output_state(uint8_t gpio_bit, uint8_t level)
{
    uint8_t data;
    esp_err_t res = ESP_FAIL;

    pca9557_register_read(PCA9557_OUTPUT_PORT, &data, 1);
    res = pca9557_register_write_byte(PCA9557_OUTPUT_PORT, SET_BITS(data, gpio_bit, level));

    return res;
}

// 控制 PCA9557_LCD_CS 引脚输出高低电平 参数0输出低电平 参数1输出高电平 
void lcd_cs(uint8_t level)
{
    pca9557_set_output_state(LCD_CS_GPIO, level);
}

// 控制 PCA9557_PA_EN 引脚输出高低电平 参数0输出低电平 参数1输出高电平 
void pa_en(uint8_t level)
{
    pca9557_set_output_state(PA_EN_GPIO, level);
}

// 控制 PCA9557_DVP_PWDN 引脚输出高低电平 参数0输出低电平 参数1输出高电平 
void dvp_pwdn(uint8_t level)
{
    pca9557_set_output_state(DVP_PWDN_GPIO, level);
}

/***************    IO扩展芯片 ↑   *************************/
/***********************************************************/





    pca9557_init(); //初始化IO扩展芯片
    pa_en(1); // 打开音频
```

# 配置自己的音乐

1. 选择一个音乐任何格式都行（比如mp3）
2. 安装ffmpeg
3. Check your music format using ```ffprobe a.mp3```, you can get the stream format (e.g. Stream #0.0: Audio: mp3, 44100Hz, stereo, s16p, 64kb/s)
4. 裁剪音乐，`ffmpeg -i  a.mp3 -ss 00:00:00  -t  00:00:20  a_cut.mp3`
5. 把音乐转换成.pcm格式 `ffmpeg -i a_cut.mp3 -f s16ls -ar 16000 -ac -1 -acodec pcm_s16le a.pcm`
6. 把.pcm格式的音乐添加到main文件夹下面
7. Replace 'canon.pcm' with 'a.pcm' in 'CMakeLists.txt' under 'main' directory
8. Replace '_binary_canon_pcm_start' and '_binary_canon_pcm_end' with '_binary_a_pcm_start' and '_binary_a_pcm_end' in 
9. Download the example and enjoy your own music
