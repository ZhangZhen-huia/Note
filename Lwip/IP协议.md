# IP协议简介

IP协议是TCP/IP协议族中最为核心的协议，为上层提供无连接，不可靠的服务

TCP、UDP、ICMP、IGMP数据都以IP数据报格式传输（IPv4、IPv6）

- 无连接：指IP通信双方都不长久维持对方的任何信息，则表示上层协议每次发送数据都需要指定IP

- 不可靠：指IP协议不能把IP数据准确送达接收端，一旦发送失败，只会通知上层协议，不会重发（TCP会尝试重发）

  

![image-20250429085330025](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504290853305.png)

***IP地址的组成***（IPV4）

- **格式**：由4个十进制数组成，每个数范围0~255，用点分隔。
  **示例**：`192.168.1.1`
- **组成部分**：
  - **网络部分（Network ID）**：标识设备所属的网络。
  - **主机部分（Host ID）**：标识网络中的具体设备。
  - **子网掩码**：区分网络和主机部分（如`255.255.255.0`表示前3组为网络地址）。
- **分类**：
  - **A类**：首字节为网络地址（1~126），后3字节为主机地址（大型网络）。
  - **B类**：前2字节为网络地址（128~191），后2字节为主机地址（中型网络）。
  - **C类**：前3字节为网络地址（192~223），末字节为主机地址（小型网络）。
  - **D类**：用于组播（224~239）。
  - **E类**：保留地址（240~255）。

# MAC地址和IP地址的区别

![image-20250429085718925](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504290857995.png)

![image-20250429090432142](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504290904219.png)

# IP分片

分片其实就是偏移payload指针

![image-20250429093250549](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504290932590.png)

## identification 

⽤来标识⼀个分⽚ ，例如：4000字节需要分⽚，分成1500， 1500， 1060，三⽚ ，***这些数据包的 identification字段都是⼀致的***

20+1480 + 20+1480 +20 + x

x = 4000-1480-1480 = 1040

所以分为1500 1500 1060三片（20是IP首部）

## flags

![image-20250429093357046](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504290933084.png)

## fragment offset

- fragment offset也叫偏移量，偏移的计算是payload部分，一般为8的倍数
- payload指的是去掉⼆层头部和三层头部后的内容 
- 1500字节的分⽚，指的是IP+payload的⼤⼩ 
- 加上E2，整个数据包抓包看到的⼤⼩是1514字节 

![image-20250429091945686](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504290919730.png)

| **字段名**        | **位数** | **功能说明**                                                 |
| :---------------- | :------- | :----------------------------------------------------------- |
| **版本号**        | 4位      | 表示IP协议版本，IPv4固定为`0100`（二进制），即十进制`4`。    |
| **首部长度**      | 4位      | 指示IP头部的总长度（以4字节为单位）。例如，值为`5`表示头部长度为20字节。基本头部为20字节（无选项字段），最大可扩展至60字节 |
| **服务类型(TOS)** | 8位      | 定义服务质量（QoS）参数，如优先级、延迟、吞吐量等（实际使用较少）。 |
| **总长度**        | 16位     | 整个IP数据包（头部+数据区）的总长度（单位为字节），最大值为65535字节。当数据包超过网络链路的最大传输单元（MTU，默认为1500字节）时，会被分片传输 |

| **字段名**     | **位数** | **功能说明**                                                 |
| :------------- | :------- | :----------------------------------------------------------- |
| **标识**       | 16位     | 唯一标识一个数据包。若数据包被分片，所有分片共享同一标识，便于接收端重组。 |
| **标志**       | 3位      | 控制分片行为： - **第1位**：保留（必须为0） - **第2位（DF）**：禁止分片 - **第3位（MF）**：更多分片（若为1，表示后续还有分片）。 |
| **片分偏移量** | 13位     | 指示当前分片在原始数据包中的位置（以8字节为单位）。用于重组分片后的数据包。 |

| **字段名**        | **位数** | **功能说明**                                                 |
| :---------------- | :------- | :----------------------------------------------------------- |
| **生存时间(TTL)** | 8位      | 防止数据包无限循环。每经过一个路由器，TTL减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop） |
| **协议**          | 8位      | 指示数据区承载的上层协议类型： - `1`: ICMP - `6`: TCP - `17`: UDP |
| **首部校验和**    | 16位     | 校验头部数据的完整性。接收端重新计算校验和，若与字段值不符，则丢弃数据包。 |

| **字段名**     | **位数** | **功能说明**                                                 |
| :------------- | :------- | :----------------------------------------------------------- |
| **源IP地址**   | 32位     | 发送方的IPv4地址（如`192.168.1.1`）。                        |
| **目的IP地址** | 32位     | 接收方的IPv4地址（如`10.0.0.2`）。                           |
| **选项字段**   | 可变长度 | 可选扩展功能（如记录路由、时间戳），普通数据包通常不包含此字段。 |
| **数据区**     | 可变长度 | 实际传输的有效载荷（如TCP/UDP数据）。                        |

***使用TCP协议的时候是不会对ip进行分片的，只会在传输层进行数据的分片***

***UDP协议会对ip分片***

## 分片原理（没听懂）

- 申请一个pbuf：内存堆，TCP模式，有54字节的内存用于保存头部（TCP首部20个字节（传输层）+ IP首部20个字节（网络层）+ 14字节网络层头部）
- ip4_frag()分片函数，在`ip4_output_if_src`(这个函数就是把传输层的pbuf数据包传输到网路层) 被调用

![image-20250429121024510](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504291210552.png)

# IP重装

由于到达的顺序是不确定的, 所以后发送的分组可能前到达

- 接收到的分片暂存起来
- 对分片进行排序
- 所有分片接收完成后，再将数据递交给传输层处理

```c
/*重组数据结构体*/
struct ip_reassdata {
  struct ip_reassdata *next;	//指向下一个需要组合的IP数据包指针，即指向下一个重装节点
  struct pbuf *p;			   //指向pbuf分片
  struct ip_hdr iphdr;		   //IP数据报首部
  u16_t datagram_len;		   //已经获取的数据的长度
  u8_t flags;				  //是否获取到了最后一个数据包
  u8_t timer;				  //超时时间，若是接收到两个重装节点的时间间隔大于超时时间，那第一个重装节点和pbuf都会被丢弃
};
```

> 每一个 ip_reassdata 结构体代表一个正在重装的 IP数据报。当接收到分组时，会将分组的 pbuf 连 接到对应 ip_reassdata 里的 pbuf 链中。当 IP数据报接收完整后才递交上层。

![image-20250429143529874](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504291435951.png)

```c
struct ip_reass_helper {
  PACK_STRUCT_FIELD(struct pbuf *next_pbuf);/*指向下一个 pbuf 指针*/
  PACK_STRUCT_FIELD(u16_t start);		/* 该分组数据起始序号---用来确认分片的位置 */
  PACK_STRUCT_FIELD(u16_t end);			/* 数据结束序号---用来确认分片的位置 */
} PACK_STRUCT_STRUCT;
```

## ip4_reass()

- 首先会获取IP首部，分片的偏移量和该分片的长度
- 从重装链表组中找到该分片对应的reassdatagrams（即通过对比首部IP是否一致），若没有就创建一个新的重装链表
- 如果是第一个分片即偏移为0，那就复制输入分组的 ip 首部到 ipr 的 iphdr 成员，由它的首部作为完整数据报的 ip 首部 
- 如果是是最后一个分组.MF = 0，那就计算数据报长度，看是否超过最大字节65535
- `ip_reass_chain_frag_into_datagram_and_validate`函数来把分片插入ip_reassdata重装链表，同时会判断新的分片是否是重复的，若是则丢弃，在这个函数里面还会对分片进行排序，最后在获取到最后一个分组以后, 会在获取分片的时候判断所有的分片是不是已经连续了（即判断分片的顺序，如132就是不连续的）, 是的话返回IP_REASS_VALIDATE_TELEGRAM_FINISHED
- 接收完成后会统计一下有多少个pbuf，如果是最后一片，就会把数据报长度和数据报标志保存在节点的结构体中
  - ![image-20250429150751759](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504291507802.png)
  - ![image-20250429151608108](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504291516179.png)
- 构建一个存放完整ip数据报的pbuf链（填充首部（把iphdr中存放的首部放到第一个分片的被以八字节强制转换成3个字段的位置），连接 pbuf），把除分片1的全部的pbuf的偏移指向数据, 并将ipr从reassdatagrams链表删除
  - ![image-20250429151019045](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504291510102.png)
- 返回pbuf的首地址（第一个分片的地址）

这一个过程是在`ip4_inpu`t函数里面调用的, 获取到完整的分片之后，会把IP首部记录下来，然后删除第一个分片的IP首部偏移量，此时第一个首部的数据就包括了TCP/UDP的首部＋数据，然后把三个分片的数据包和在一起之后，然后根据协议的类型来做不同的处理，最后发到传输层

![image-20250429152259843](https://raw.githubusercontent.com/ZhangZhen-huia/Note/main/img/202504291523012.png)